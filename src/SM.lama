-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Builtins;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn(i) {
  -- Shows a location(a reference to function argument, local or global variable)
  fun showLoc(d) {
    case d of
      Arg(i) -> sprintf("arg[%d]", i)
    | Loc(i) -> sprintf("loc[%d]", i)
    | Glb(x) -> x
    esac
  }
  
  case i of
    BINOP(s)       -> sprintf("BINOP %s", s)
  | LD(x)       -> sprintf("LD %s", showLoc(x))
  | LDA(x)       -> sprintf("LDA %s", showLoc(x))
  | ST(x)       -> sprintf("ST %s", showLoc(x))
  | STI              -> "STI"
  | CONST(n)       -> sprintf("CONST %d", n)
  | LABEL(s)       -> sprintf("LABEL %s", s)
  | JMP(l)       -> sprintf("JMP %s", l)
  | CJMP(c, l)    -> sprintf("CJMP %s, %s", c, l)
  | CALL(f, n)    -> sprintf("CALL %s, %d", f, n)
  | BEGIN(f, a, l) -> sprintf("BEGIN %s, %d, %d", f, a, l)
  | GLOBAL(x)       -> sprintf("GLOBAL %s", x)
  | END              -> sprintf("END")
  | DUP              -> "DUP"
  | DROP             -> "DROP"
  | STRING(s)       -> sprintf("STRING ""%s""", s)
  | ARRAY(n)       -> sprintf("ARRAY %d", n)
  | SEXP(t, n)    -> sprintf("SEXP %s %d", t, n)
  | STA              -> "STA"
  | ELEM             -> "ELEM"
  | BUILTIN(f, n)   -> sprintf("BUILTIN %s, %d", f, n)
  esac
}

public fun showSM(prg) {
  map(fun(i) {showSMInsn(i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and(sub)programs
fun initEvalEnv(insns) {
  var map =
    fix(fun(rec) {
          fun([m, insns]) {
            case insns of
              {}               -> m
            | LABEL(lab) : tl -> rec([addMap(m, lab, insns), tl])
            | _ : tl           -> rec([m, tl])
            esac
          }
        }) $ [emptyMap(compare), insns];
  
  [fun(l) {
     case findMap(map, l) of Some(insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel(env, lab) {
  env [0](lab)
}

-- Stack machine interpreter. Takes an environment, a world and a program,
-- returns a final output
fun eval(env, w, insns) {
  -- Global state maps names of global variables to values
  var globalState = ref(fun(x) {error(sprintf("name ""%s"" is undefined", x), getLoc(x))});
  
  -- Make a fresh local state: a pair of arrays for arguments and local variables;
  -- takes the numbers of arguments and local variables respectively
  fun makeState(a, l) {
    [initArray(a, fun(_) {0}), initArray(l, fun(_) {0})]
  }

  -- Lookups a location in local/global states
  fun lookup([args, locs], loc) {
    case loc of
      Arg(i) -> args[i]
    | Loc(i) -> locs[i]
    | Glb(x) -> deref(globalState)(x)
    esac 
  }

  -- Assigns a value to a location
  fun assign([args, locs], loc, vl) {
    case loc of
      Arg(i) -> args[i] := vl
    | Loc(i) -> locs[i] := vl
    | Glb(x) -> var g = deref(globalState);
                 globalState ::= fun(y) {if compare(x, y) == 0 then vl else g(y) fi}
    esac
  }

  -- Takes n positions from the list, retursn a pair: the remaining list and the taken
  -- sublist
  fun take(list, n) {
    fun inner(n, acc, list) {
      if n == 0
      then [list, acc]
      else inner(n-1, list.hd : acc, list.tl)
      fi
    }

    inner(n, {}, list)
  }

  -- Core interpreter: takes a configuration and a program, returns a configuration
  fun eval(c@[stack, control_stack, s, w], insns) {
    case insns of
          BINOP(op):insns_rest -> let r:l:stack_rest = stack in eval([evalOp(op, l, r):stack_rest, control_stack, s, w], insns_rest) 
        | CONST(x):insns_rest -> eval([x:stack, control_stack, s, w], insns_rest) 
        | READ:insns_rest -> let [inp, w] = readWorld(w) in eval([inp:stack, control_stack, s, w], insns_rest)
        | WRITE:insns_rest -> let out:_ = stack in eval([stack, control_stack, s, writeWorld(out, w)], insns_rest)
        | LD(x):insns_rest -> eval([lookup(s, x):stack, control_stack, s, w], insns_rest)
        | LDA(x):insns_rest -> eval([x:stack, control_stack, s, w], insns_rest)
        | ST(x):insns_rest -> let v:_ = stack in assign(s, x, v); eval([stack, control_stack, s, w], insns_rest)
        | STI:insns_rest ->  let v:x:stack_rest = stack in assign(s, x, v); eval([v:stack_rest, control_stack, s, w], insns_rest)
        | LABEL(_):insns_rest -> eval(c, insns_rest)
        | JMP(l):_ -> eval(c, fromLabel(env, l))
        | CJMP(c, l):insns_rest -> let x:stack_rest = stack in
            if case c of 
                  "z" -> x == 0 
                | "nz" -> x != 0
            esac then
                eval([stack_rest, control_stack, s, w], fromLabel(env, l))
            else
                eval([stack_rest, control_stack, s, w], insns_rest)
            fi
        | DROP:insns_rest -> let _:stack_rest = stack in eval([stack_rest, control_stack, s, w], insns_rest)
        | END:_ -> case control_stack of
                  [s, cont]:control_stack_rest -> eval([stack, control_stack_rest, s, w], cont)
                | _ -> c
            esac
        | BEGIN(_, argc, n_loc):insns_rest -> let [stack, a] = take(stack, argc) in
            let [_, l] = makeState(argc, n_loc) in
            eval([stack, control_stack, [listArray(a), l], w], insns_rest)
        | CALL(n, _):insns_rest -> eval([stack, [s, insns_rest]:control_stack, s, w], fromLabel(env, n))
        | GLOBAL(x):insns_rest -> eval(c, insns_rest)
        | STRING(x):insns_rest -> eval([x : stack, control_stack, s, w], insns_rest)
        | ARRAY(n):insns_rest -> let [_ : stack, l] = take(stack, n) in eval([listArray(l) : stack, control_stack, s, w], insns_rest)
        | STA:insns_rest -> case stack of
                  v : (i@#val) : (arr@#array) : stack -> arr[i] := v; eval([v : stack, control_stack, s, w], insns_rest)
                | v : (i@#val) : (arr@#str) : stack -> arr[i] := v; eval([v : stack, control_stack, s, w], insns_rest)
                | v : (i@#val) : Sexp(_, arr) : stack -> arr[i] := v; eval([v : stack, control_stack, s, w], insns_rest)
            esac
        | ELEM:insns_rest -> case stack of
                  (i@#val) : (arr@#array) : stack -> eval([arr[i] : stack, control_stack, s, w], insns_rest)
                | (i@#val) : (arr@#str) : stack -> eval([arr[i] : stack, control_stack, s, w], insns_rest)
                | (i@#val) : Sexp(_, arr) : stack -> eval([arr[i] : stack, control_stack, s, w], insns_rest)
            esac
        | BUILTIN(f, n):insns_rest -> let [stack, l] = take(stack, n) in
            let [v, w] = evalBuiltin(f, l, w) in
            eval([v : stack, control_stack, s, w], insns_rest)
        | SEXP(tag, n):insns_rest ->  let [_ : stack, l] = take(stack, n) in eval([Sexp(tag, listArray(l)) : stack, control_stack, s, w], insns_rest)
    esac
  }

  eval([{}, {}, makeState(0, 0), w], insns) [3].getOutput
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM(input, insns) {
  eval(initEvalEnv(insns), createWorld(input), insns)
}

-- Compilation environment: generates labels
fun makeCompEnv(nLabels, scopeDepth, state, nLocals, nArgs, functions) {
  -- Generates a new label
  fun genLabel() {
    [sprintf("L%d", nLabels), makeCompEnv(nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
  }

  -- Adds a new function 
  fun rememberFun(fLabel, args, body) {
    makeCompEnv(nLabels,
                 scopeDepth,
                 state,
                 nLocals,
                 nArgs,
                 Fun(fLabel, args, body, state) : functions)
  }

  -- Enters a local scope
  fun beginScope() {
    makeCompEnv(nLabels, scopeDepth+1, enterScope(state), nLocals, nArgs, functions)
  }

  -- Leaves a local scope
  fun endScope() {
    makeCompEnv(nLabels, scopeDepth-1, leaveScope(state), nLocals, nArgs, functions)
  }

  -- Adds an argument for the current function
  fun addArg(name) {
    makeCompEnv(nLabels, scopeDepth, addName(state, name, Arg(nArgs)), nLocals, nArgs+1, functions)
  }

  -- Adds a local variable for the current function
  fun addVar(name) {
    if isGlobal()
    then makeCompEnv(nLabels, scopeDepth, addName(state, name, Glb(name)), nLocals, nArgs, functions)
    else makeCompEnv(nLabels, scopeDepth, addName(state, name, Loc(nLocals)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a binding for a function
  fun addFun(name, fLabel, nargs) {
    makeCompEnv(nLabels, scopeDepth, addName(state, name, Fun(fLabel, nargs)), nLocals, nArgs, functions)
  }
  
  -- Enters a function
  fun beginFun(state) {
    makeCompEnv(nLabels, 2, enterFunction(state), 0, 0, functions)
  }

  -- Get functions and empty functions list
  fun getFuns() {
    [functions, makeCompEnv(nLabels, scopeDepth, state, nLocals, nArgs, {})]
  }

  -- Lookups a name of a variable
  fun lookupVar(name) {
    case lookup(state, name) of
      Fun(_, _) -> error(sprintf("the name ""%s"" does not designate a variable", name), getLoc(name))
    | x          -> x
    esac
  }

  -- Lookups a name of a function
  fun lookupFun(name) {
    case lookup(state, name) of
      x@Fun(_, _) -> x
    | _            -> error(sprintf("the name ""%s"" does not designate a function", name), getLoc(name))
    esac
  }

  -- Gets the number of local variables
  fun getLocals() {
    nLocals
  }

  -- Generates an intrinsic function name
  fun genFunLabel(name) {
     if isGlobal()
     then [sprintf("L%s", name),             makeCompEnv(nLabels  , scopeDepth, state, nLocals, nArgs, functions)]
     else [sprintf("L%s_%d", name, nLabels), makeCompEnv(nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
     fi 
  }

  -- Checks if the current scope is a global
  fun isGlobal() {
    scopeDepth == 2
  }
  
  [genLabel,
   rememberFun,
   beginScope,
   endScope,
   addArg,
   addVar,
   beginFun,
   getFuns,
   lookupVar,
   lookupFun,
   getLocals,
   genFunLabel,
   addFun,
   isGlobal
  ]
}

-- Initialize a new compilation environment
fun initCompEnv() {
  makeCompEnv(0, 1, enterScope(emptyState()), 0, 0, {})
}

-- Accessor functions
fun genLabel(env) {
  env [0]()
}

fun rememberFun(env, name, args, body) {
  env [1](name, args, body)
}

fun beginScope(env) {
  env [2]()
}

fun endScope(env) {
  env [3]()
}

fun addArg(env, name) {
  env [4](name)
}

fun addVar(env, name) {
  env [5](name)
}

fun beginFun(env, state) {
  env [6](state)
}

fun getFuns(env) {
  env [7]()
}

fun lookupVar(env, name) {
  env [8](name)
}

fun lookupFun(env, name) {
  env [9](name)
}

fun getLocals(env) {
  env [10]()
}

fun genFunLabel(env, name) {
  env [11](name)
}

fun addFun(env, name, fLabel, nargs) {
  env [12](name, fLabel, nargs)
}

fun isGlobal(env) {
  env [13]()
}

-- Helper function: generates n labels
fun genLabels(env, n) {
  fun inner(env, n) {
    if n == 0
    then {env}
    else case genLabel(env) of
           [lab, env] -> lab : inner(env, n-1)
         esac
    fi
  }

  listArray(inner(env, n))
}

-- Helper function: adds a bunch of arguments
fun addArgs(env, names) {
  foldl(fun(env, name) {addArg(env, name)}, env, names)
}

-- Helper function: adds a bunch of locals
fun addVars(env, names) {
  foldl(fun(env, name) {addVar(env, name)}, env, names)
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM(stmt) {
  fun label(l, lUsed) {
    if lUsed
    then singletonBuffer(LABEL(l))
    else emptyBuffer()
    fi
  }
  
  fun compileMany(lab, env, exprs) {
    case exprs of
      {}     -> [false, env, emptyBuffer()]
    | e : es ->
        case env.genLabel of
          [l1, env] ->
            case compile(l1, env, e) of
              [eUsed, env, ec] ->
                 case compileMany(lab, env, es) of
                   [labUsed, env, esCode] -> [labUsed, env, ec <+> label(l1, eUsed) <+> esCode]
                 esac
            esac
        esac
    esac
  }

  fun compile(l, env, stmt) {
    case stmt of
      Skip -> [false, env, emptyBuffer()]
    | Var(x) -> [false, env, singletonBuffer(LD(lookupVar(env, x)))]
    | Ref(x) -> [false, env, singletonBuffer(LDA(lookupVar(env, x)))]
    | Const(n) -> [false, env, singletonBuffer(CONST(n))]
    | String(s) -> [false, env, singletonBuffer(STRING(s))]
    | Binop(s, l, r) -> let [l1, l2, env] = genLabels(env, 2) in 
        let [l3, env, lc] = compile(l1, env, l) in 
        let [l4, env, rc] = compile(l2, env, r) in
        [false, env, lc <+> label(l1, l3) <+> rc <+> label(l2, l4) <+ BINOP(s)] 
    | Assn(Ref(x), e) -> let [l1, env] = genLabel(env) in 
        let [l2, env, ec] = compile(l1, env, e) in
        [false, env, ec <+> label(l1, l2) <+ ST(lookupVar(env, x))]
    | Assn(x@ElemRef(a, b), e) -> let [l1, env] = genLabel(env) in 
        let [l2, env, ec] = compileMany(l1, env, {x, e}) in
        [false, env,(ec <+> label(l1, l2)) <+ STA]
    | Assn(x, e) -> let [l1, l3, env] = genLabels(env, 2) in 
        let [l2, env, xc] = compile(l1, env, x) in
        let [l4, env, ec] = compile(l3, env, e) in
        [false, env, xc <+> label(l1, l2) <+> ec <+> label(l3, l4) <+ STI]
    | Seq(s1, s2) -> let [l1, env] = genLabel(env) in
        let [l2, env, c1] = compile(l1, env, s1) in
        let [l3, env, c2] = compile(l, env, s2) in
        [l3, env, c1 <+> label(l1, l2) <+> c2]
    | If(con, t, f) -> let [l1, l2, env] = genLabels(env, 2) in
        let [l3, env, ccon] = compile(l2, env, con) in 
        let [_, env, ct] = compile(l, env, t) in 
        let [_, env, cf] = compile(l, env, f) in
        [true, env, ccon <+> label(l2, l3) <+ CJMP("z", l1) <+> ct <+ JMP(l) <+ LABEL(l1) <+> cf]
    | While(con, b) -> compile(l, env, If(con, DoWhile(b, con), Skip))
    | DoWhile(b, con) -> let [l1, l2, l3, env] = genLabels(env, 3) in
        let [l4, env, ccon] = compile(l3, env, con) in
        let [l5, env, cb] = compile(l1, env, b) in
        [false, env, label(l2, true) <+> cb <+> label(l1, l5) <+> ccon <+> label(l3, l4) <+ CJMP("nz", l2)]
    | Ignore(e) -> let [l1, env] = genLabel(env) in
        let [l2, env, c] = compile(l1, env, e) in
        [false, env, c <+ DROP]
    | Scope(d, e) -> let env = beginScope(env) in
        let env = foldl(fun(env, def) {
            case def of
                  Var(n) -> addVars(env, n)
                | Fun(n, a, b) -> let [l, env] = genFunLabel(env, n) in addFun(env, n, l, size(a))
            esac
            }, env, d) in
        let env = foldl(fun(env, def) {
            case def of
                  Var(_) ->  env
                | Fun(n, a, b) -> let [l, env] = genFunLabel(env, n) in rememberFun(env, l, a, b)
            esac
        }, env, d) in
        let code = if isGlobal(env)
        then foldl(fun(code, def) {
            case def of
                Var(n) -> foldl(fun(code, x) {
                        code <+ GLOBAL(x)
                    }, code, n)
                | _ -> code
            esac
            }, emptyBuffer(), d)
        else emptyBuffer()
        fi in 
        let [l, env, c] = compile(l, env, e) in
        [l, endScope(env), code <+> c]
    | Call(f, a) ->  let Fun(n, _) = lookupFun(env, f) in 
        let [l1, env] = genLabel(env) in 
        let [l2, env, c] = compileMany(l1, env, a) in
        [false, env, c <+> label(l1, l2) <+ case n of Builtin -> BUILTIN(f, size(a)) | _ -> CALL(n, size(a)) esac]
    | String(s) -> [false, env, singletonBuffer(STRING(s))]
    | Array(a) -> let [l1, env] =  genLabel(env) in
        let [l2, env, ec] = compileMany(l1, env, a) in
        [false, env, emptyBuffer() <+ CONST(size(a)) <+> ec <+> label(l1, l2) <+ ARRAY(size(a))]
    | Sexp(n, a) -> let [l1, env] =  genLabel(env) in
        let [l2, env, ec] = compileMany(l1, env, a) in
        [false, env, emptyBuffer() <+ CONST(size(a)) <+> ec <+> label(l1, l2) <+ SEXP(n, size(a))]
    | Elem(a, i) -> let [l1, env] = genLabel(env) in
        let [l2, env, ec] = compileMany(l1, env, {a, i}) in 
        [false, env,(ec <+> label(l1, l2)) <+ ELEM]
    | ElemRef(a, i) ->  let [l1, env] = genLabel(env) in
        let [l2, env, ec] = compileMany(l1, env, {a, i}) in 
        [false, env,(ec <+> label(l1, l2))]
    | Builtin(f, a) -> let [l1, env] = genLabel(env) in
        let [l2, env, ec] = compileMany(l1, env, a) in 
        [false, env, ec <+> label(l1, l2) <+ BUILTIN(f, size(a))]
    esac
  }

  fun compileFunctions(env, main) {
    fun iterate(env, funList) {
      case funList of
        {}     -> case getFuns(env) of
                    [{}, env] -> emptyBuffer()
                  | [fs, env] -> iterate(env, fs)
                  esac
      | Fun(f, args, body, state) : fs ->
          case genLabel(addArgs(beginFun(env, state), args)) of
            [endLab, env] ->
               case compile(endLab, env, body) of
                 [endUsed, env, code] -> 
                    singletonBuffer(LABEL(f)) <+
                    BEGIN(f, size(args), getLocals(env)) <+>
                    code <+>
                    label(endLab, endUsed) <+
                    END <+>
                    iterate(env, fs)
               esac
          esac          
      esac
    }
    
    main <+> iterate(env, {})
  }
  
  case genLabel(initCompEnv()) of
    [endLab, env] ->
       case compile(endLab, env, stmt) of
         [endLabUsed, env, code] ->
            getBuffer $
            compileFunctions(env, 
                              singletonBuffer(LABEL("main")) <+
                              BEGIN("main", 0, getLocals(env)) <+>
                              code <+>
                              label(endLab, endLabUsed) <+
                              END 
                             )            
       esac
  esac
}
