-- Stack machine.
import List;
import World;
import State;
import Expr;
import Stmt;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (instruction) {
   case instruction of
     CONST(n) -> sprintf("CONST %d", n)
   | LD(x)    -> sprintf("LD %s", x)
   | ST(x)    -> sprintf("ST %s", x)
   | BINOP(s) -> sprintf("BINOP %s", s)
   | READ     -> sprintf("READ")
   | WRITE    -> sprintf("WRITE")
   esac
}
public fun showSM (program_code) {
   map(fun (instr) {showSMInsn(instr) ++ "\n"}, program_code).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (current_config@[sm_stack, current_state, world_obj], instruction_list) {
   case instruction_list of
      {} -> [sm_stack, current_state, world_obj] 
      | current_insn : rest_insns -> 
         case current_insn of
            CONST(num_const) -> eval([num_const:sm_stack, current_state, world_obj], rest_insns)

            | LD(var_to_load) -> 
               eval([current_state(var_to_load):sm_stack, current_state, world_obj], rest_insns)

            | ST(var_to_store) ->
               case sm_stack of 
                  val_on_top:remaining_stack -> 
                     eval([remaining_stack, current_state <- [var_to_store, val_on_top], world_obj], rest_insns) 
                  | {} -> failure("SM Error: ST on empty stack\n") 
               esac

            | BINOP(op_symbol) ->
               case sm_stack of 
                  val2:val1:remaining_stack -> 
                     eval([evalBinop(op_symbol, val1, val2):remaining_stack, current_state, world_obj], rest_insns) 
                  | _ -> failure("SM Error: BINOP needs 2 operands on stack\n")
               esac

            | READ ->  
               case readWorld(world_obj) of 
                  [input_val, new_world_obj] -> eval([input_val:sm_stack, current_state, new_world_obj], rest_insns) 
                  | _ -> failure("SM Error: READ failed or no input\n") 
               esac

            | WRITE -> 
               case sm_stack of 
                  val_to_write:remaining_stack -> 
                     eval([remaining_stack, current_state, writeWorld(val_to_write, world_obj)], rest_insns) 
                  | {} -> failure("SM Error: WRITE on empty stack\n") 
               esac
         esac
   esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (program_input, sm_instructions) {
   eval([{}, emptyState, createWorld(program_input)], sm_instructions)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list
-- of stack machine instructions
fun compileExpr (expr_node) {
   case expr_node of
      Const(n_val) -> {CONST(n_val)}
    | Var(x_name)   -> {LD(x_name)}
    | Binop(op_sym, sub_e1, sub_e2) -> compileExpr(sub_e1) +++ compileExpr(sub_e2) +++ {BINOP(op_sym)}
   esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt_node) {
   case stmt_node of
      Assn(var_n, expr_n) -> compileExpr(expr_n) +++ {ST(var_n)}
    | Seq(s1, s2)   -> compileSM(s1) +++ compileSM(s2)
    | Skip          -> {}
    | Read(var_n)   -> {READ, ST(var_n)}
    | Write(expr_n) -> compileExpr(expr_n) +++ {WRITE}
   esac
}