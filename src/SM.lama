-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn(i) {
  case i of
      READ      -> sprintf("READ")
    | WRITE     -> sprintf("WRITE")
    | BINOP (s) -> sprintf("BINOP %s", s)
    | LD    (x) -> sprintf("LD %s", x)
    | ST    (x) -> sprintf("ST %s", x)
    | CONST (n) -> sprintf("CONST %d", n)
  esac
}

public fun showSM(prg) {
  map(fun (i) { showSMInsn(i) ++ "\n" }, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval(c@[st, s, w], insns) {
  case insns of
      { }       -> c
    | i : insns ->
      eval(
        case i of
            READ       -> case readWorld(w) of [n, w] -> [n:st, s, w] esac
          | WRITE      -> case st of n : st -> [st, s, writeWorld(n, w)] esac
          | BINOP (op) -> case st of y : x : st -> [getOp(op)(x, y):st, s, w] esac
          | CONST (n)  -> [n:st, s, w]
          | LD (x)     -> [s(x):st, s, w]
          | ST (x)     -> case st of n : st -> [st, s <- [x, n], w] esac
        esac,
        insns
      )
  esac
}


-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM(input, insns) {
  eval([{ }, emptyState, createWorld(input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr(expr) {
  case expr of
      Var(ident)       -> { LD(ident) }
    | Const(n)         -> { CONST(n) }
    | Binop (op, x, y) -> compileExpr(x) +++ compileExpr(y) +++ { BINOP(op) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM(stmt) {
  case stmt of
      Skip              -> { }
    | Assn(ident, expr) -> compileExpr(expr) +++ { ST(ident) }
    | Read(ident)       -> { READ, ST(ident) }
    | Write(expr)       -> compileExpr(expr) +++ { WRITE }
    | Seq(stmt1, stmt2) -> compileSM(stmt1) +++ compileSM(stmt2)
  esac
}
