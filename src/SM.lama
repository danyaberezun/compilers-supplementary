-- Stack machine.
import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
   case i of
     READ     -> sprintf("READ")
   | WRITE    -> sprintf("WRITE")
   | BINOP(s) -> sprintf("BINOP %s", s)
   | LD(x)    -> sprintf("LD %s", x)
   | ST(x)    -> sprintf("ST %s", x)
   | CONST(n) -> sprintf("CONST %d", n)
   esac
}
public fun showSM (prg) {
   map(fun (i) {showSMInsn(i) ++ "\n"}, prg).stringcat
}
-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval ([stack, state, world], insns) {
   case insns of
      {} -> [stack, state, world]
   |  head:tail -> 
      case head of
         READ -> case readWorld(world) of [v, w] -> eval ([v:stack, state, w], tail) esac
      |  WRITE -> case stack of v:rest -> eval ([rest, state, writeWorld(v, world)], tail) esac
      |  BINOP (s) -> case stack of rx:lx:rest ->
            var res = case s of 
                  "+" -> lx + rx    
               |  "-" -> lx - rx    
               |  "*" -> lx * rx    
               |  "/" -> lx / rx    
               |  "%" -> lx % rx    
               |  "<" -> lx < rx    
               |  ">" -> lx > rx    
               |  "<=" -> lx <= rx  
               |  ">=" -> lx >= rx  
               |  "==" -> lx == rx  
               |  "!=" -> lx != rx  
               |  "&&" -> lx && rx  
               |  "!!" -> lx !! rx
            esac;
            eval([res:rest, state, world], tail)
         esac
      |  LD (x) -> eval([state (x):stack, state, world], tail)
      |  ST (x) -> case stack of v:rest -> eval ([stack, state <- [x, v], world], tail) esac
      |  CONST (x) -> eval ([x:stack, state, world], tail)
      esac
   esac
}
-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
   eval([{}, emptyState, createWorld(input)], insns)[2].getOutput
}
-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
   case expr of
      Var (x) -> {LD(x)}
   |  Const (x) -> { CONST(x)}
   |  Binop (s, lexpr, rexpr) -> compileExpr(lexpr) +++ compileExpr(rexpr) +++ {BINOP(s)}
   esac
}
-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
   case stmt of 
      Assn (st, expr) -> compileExpr(expr) +++ {ST(st)}
   |  Seq (lst, rst) -> compileSM (lst) +++ compileSM (rst)
   |  Skip -> {}
   |  Read (st) -> { READ, ST(st)}
   |  Write (expr) -> compileExpr(expr) +++ {WRITE}
   esac
}