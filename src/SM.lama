-- Stack machine.
import Ref;
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
   -- Shows a location (a reference to function argument, local or global variable)
   fun showLoc (d) {
      case d of
        Arg(i) -> sprintf("arg[%d]", i)
      | Loc(i) -> sprintf("loc[%d]", i)
      | Glb(x) -> x
      esac
   }
   
   case i of
     READ           -> "READ"
   | WRITE          -> "WRITE"
   | BINOP(s)       -> sprintf("BINOP %s", s)
   | LD(x)          -> sprintf("LD %s", showLoc(x))
   | LDA(x)         -> sprintf("LDA %s", showLoc(x))
   | ST(x)          -> sprintf("ST %s", showLoc(x))
   | STI            -> "STI"
   | CONST(n)       -> sprintf("CONST %d", n)
   | LABEL(s)       -> sprintf("LABEL %s", s)
   | JMP(l)         -> sprintf("JMP %s", l)
   | CJMP(c, l)     -> sprintf("CJMP %s, %s", c, l)
   | CALL(f, n)     -> sprintf("CALL %s, %d", f, n)
   | BEGIN(f, a, l) -> sprintf("BEGIN %s, %d, %d", f, a, l)
   | GLOBAL(x)      -> sprintf("GLOBAL %s", x)
   | END            -> sprintf("END")
   | DUP            -> "DUP"
   | DROP           -> "DROP"
   esac
}
public fun showSM (prg) {
   map(fun (i) {showSMInsn(i) ++ "\n"}, prg).stringcat
}
-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
   var map = fix(fun (rec) {
                           fun ([m, insns]) {
                              case insns of
                                {}             -> m
                              | LABEL(lab): tl -> rec([addMap(m, lab, insns), tl])
                              | _: tl          -> rec([m, tl])
                              esac
                           }
                        }) $ [emptyMap(compare), insns];
   
   [fun (l) {
       case findMap(map, l) of
         Some(insns) -> insns
       esac
    }]
}
-- Accessor function
fun fromLabel (env, lab) {
   env[0](lab)
}
-- Stack machine interpreter. Takes an environment, a world and a program,
-- returns a final output
fun eval (env, w, insns) {
   -- Global state maps names of global variables to values
   var globalState = ref(fun (x) {error(sprintf("name ""%s"" is undefined", x), getLoc(x))});
   -- Make a fresh local state: a pair of arrays for arguments and local variables;
   -- takes the numbers of arguments and local variables respectively
   fun makeState (a, l) {
      [initArray(a, fun (_) {0}), initArray(l, fun (_) {0})]
   }
   -- Lookups a location in local/global states
   fun lookup ([args, locs], loc) {
      case loc of
        Arg(i) -> args[i]
      | Loc(i) -> locs[i]
      | Glb(x) -> deref(globalState)(x)
      esac
   }
   -- Assigns a value to a location
   fun assign ([args, locs], loc, v) {
      case loc of
        Arg(i) -> args[i] := v
      | Loc(i) -> locs[i] := v
      | Glb(x) -> var g = deref(globalState); globalState ::= fun (y) {if compare(x, y) == 0 then v else g(y) fi}
      esac
   }
   -- Takes n positions from the list, retursn a pair: the remaining list and the taken
   -- sublist
   fun take (list, n) {
      fun inner (n, acc, list) {
         if n == 0 then [list, acc] else inner(n - 1, list.hd : acc, list.tl) fi
      }
      
      inner(n, {}, list)
   }
   -- Core interpreter: takes a configuration and a program, returns a configuration
   (* Assignment *)
   fun eval (c@[stack, cst, s, w], insns) {
      case insns of
        BINOP(op): insns_tail             -> let r: l: stack_tail = stack in
                                                eval([evalOp(op, l, r) : stack_tail, cst, s, w], insns_tail)
      | CONST(x): insns_tail              -> eval([x : stack, cst, s, w], insns_tail)
      | READ: insns_tail                  -> let [inp, w] = readWorld(w) in
                                                eval([inp : stack, cst, s, w], insns_tail)
      | WRITE: insns_tail                 -> let out: _ = stack in
                                                eval([stack, cst, s, writeWorld(out, w)], insns_tail)
      | LD(x): insns_tail                 -> eval([lookup(s, x) : stack, cst, s, w], insns_tail)
      | LDA(x): insns_tail                -> eval([Ref(x) : stack, cst, s, w], insns_tail)
      | ST(x): insns_tail                 -> let v: _ = stack in
                                                assign(s, x, v);
                                                eval([stack, cst, s, w], insns_tail)
      | STI: insns_tail                   -> let v: Ref(x): stack_tail = stack in
                                                assign(s, x, v);
                                                eval([v : stack_tail, cst, s, w], insns_tail)
      | LABEL(_): insns_tail              -> eval(c, insns_tail)
      | JMP(l): _                         -> eval(c, fromLabel(env, l))
      | CJMP(c, l): insns_tail            -> let x: stack_tail = stack in
                                                if case c of
                                                     "z"  -> x == 0
                                                   | "nz" -> x != 0
                                                   esac
                                                then eval([stack_tail, cst, s, w], fromLabel(env, l))
                                                else eval([stack_tail, cst, s, w], insns_tail)
                                                fi
      | DROP: insns_tail                  -> let _: stack_tail = stack in eval([stack_tail, cst, s, w], insns_tail)
      | END: _                            -> case cst of
                                               [s, cont]: control_stack_tail -> eval([stack, control_stack_tail, s, w], cont)
                                             | _                             -> c
                                             esac
      | BEGIN(n, argc, n_loc): insns_tail -> let [stack, a] = take(stack, argc) in
                                                let [_, l] = makeState(argc, n_loc) in
                                                   eval([stack, cst, [listArray(a), l], w], insns_tail)
      | CALL(n, _): insns_tail            -> eval([stack, [s, insns_tail] : cst, s, w], fromLabel(env, n))
      | GLOBAL(x): insns_tail             -> assign(s, Glb(x), 0);
                                             eval(c, insns_tail)
      | _                                 -> c
      esac
   }
   
   (* End *)
   eval([{}, {}, makeState(0, 0), w], insns)[3].getOutput
}
-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
   eval(initEvalEnv(insns), createWorld(input), insns)
}
-- Compilation environment: generates labels
fun makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, functions) {
   -- Generates a new label
   fun genLabel () {
      [sprintf("L%d", nLabels), makeCompEnv(nLabels + 1, scopeDepth, state, nLocals, nArgs, functions)]
   }
   -- Adds a new function
   fun rememberFun (fLabel, args, body) {
      makeCompEnv(nLabels, scopeDepth, state, nLocals, nArgs, Fun(fLabel, args, body, state) : functions)
   }
   -- Enters a local scope
   fun beginScope () {
      makeCompEnv(nLabels, scopeDepth + 1, enterScope(state), nLocals, nArgs, functions)
   }
   -- Leaves a local scope
   fun endScope () {
      makeCompEnv(nLabels, scopeDepth - 1, leaveScope(state), nLocals, nArgs, functions)
   }
   -- Adds an argument for the current function
   fun addArg (name) {
      makeCompEnv(nLabels, scopeDepth, addName(state, name, Arg(nArgs)), nLocals, nArgs + 1, functions)
   }
   -- Adds a local variable for the current function
   fun addVar (name) {
      if scopeDepth == 1 then makeCompEnv(nLabels, scopeDepth, addName(state, name, Glb(name)), nLocals, nArgs, functions)
      else makeCompEnv(nLabels, scopeDepth, addName(state, name, Loc(nLocals)), nLocals + 1, nArgs, functions)
      fi
   }
   -- Adds a binding for a function
   fun addFun (name, fLabel, nargs) {
      makeCompEnv(nLabels, scopeDepth, addName(state, name, Fun(fLabel, nargs)), nLocals, nArgs, functions)
   }
   -- Enters a function
   fun beginFun (state) {
      makeCompEnv(nLabels, 1, enterFunction(state), 0, 0, functions)
   }
   -- Get functions and empty functions list
   fun getFuns () {
      [functions, makeCompEnv(nLabels, scopeDepth, state, nLocals, nArgs, {})]
   }
   -- Lookups a name of a variable
   fun lookupVar (name) {
      case lookup(state, name) of
        Fun(_, _) -> error(sprintf("the name ""%s"" does not designate a variable", name), getLoc(name))
      | x         -> x
      esac
   }
   -- Lookups a name of a function
   fun lookupFun (name) {
      case lookup(state, name) of
        x@Fun(_, _) -> x
      | _           -> error(sprintf("the name ""%s"" does not designate a function", name), getLoc(name))
      esac
   }
   -- Gets the number of local variables
   fun getLocals () {
      nLocals
   }
   -- Generates an intrinsic function name
   fun genFunLabel (name) {
      if scopeDepth == 1 then [sprintf("L%s", name), makeCompEnv(nLabels, scopeDepth, state, nLocals, nArgs, functions)]
      else [sprintf("L%s_%d", name, nLabels), makeCompEnv(nLabels + 1, scopeDepth, state, nLocals, nArgs, functions)]
      fi
   }
   -- Checks if the current scope is a global
   fun isGlobal () {
      scopeDepth == 1
   }
   
   [genLabel,
    rememberFun,
    beginScope,
    endScope,
    addArg,
    addVar,
    beginFun,
    getFuns,
    lookupVar,
    lookupFun,
    getLocals,
    genFunLabel,
    addFun,
    isGlobal]
}
-- Initialize a new compilation environment
fun initCompEnv () {
   makeCompEnv(0, 0, emptyState(), 0, 0, {})
}
-- Accessor functions
fun genLabel (env) {
   env[0]()
}
fun rememberFun (env, name, args, body) {
   env[1](name, args, body)
}
fun beginScope (env) {
   env[2]()
}
fun endScope (env) {
   env[3]()
}
fun addArg (env, name) {
   env[4](name)
}
fun addVar (env, name) {
   env[5](name)
}
fun beginFun (env, state) {
   env[6](state)
}
fun getFuns (env) {
   env[7]()
}
fun lookupVar (env, name) {
   env[8](name)
}
fun lookupFun (env, name) {
   env[9](name)
}
fun getLocals (env) {
   env[10]()
}
fun genFunLabel (env, name) {
   env[11](name)
}
fun addFun (env, name, fLabel, nargs) {
   env[12](name, fLabel, nargs)
}
fun isGlobal (env) {
   env[13]()
}
-- Helper function: generates n labels
fun genLabels (env, n) {
   fun inner (env, n) {
      if n == 0 then {env}
      else case genLabel(env) of
             [lab, env] -> lab : inner(env, n - 1)
           esac
      fi
   }
   
   listArray(inner(env, n))
}
-- Helper function: adds a bunch of arguments
fun addArgs (env, names) {
   foldl(fun (env, name) {addArg(env, name)}, env, names)
}
-- Helper function: adds a bunch of locals
fun addVars (env, names) {
   foldl(fun (env, name) {addVar(env, name)}, env, names)
}
-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
(* Assignment *)
-- Some guidelines for compiling functions and scopes.
--
-- 1. use env.beginScope/env.endScope properly;
-- 2. in each scope traverse the definitions twice:
--    a. first, add all bindings into symbolic state,
--       using end.addVar/env.addFun;
--    b. do not forget to generate GLOBAL instructions for
--       top-level variable declarations;
--    c. on the secord traversal add functions themselves for
--       future code generation (use env.rememberFun).
-- 3. the overall flow for code generation:
--    a. generate the code for the topmost expression (the program itself);
--    b. take list of nested functions definitions via env.getFuns and
--       generate the code for each function;
--    c. repeat b. until no function definitions appear.
-- 4. when compiling functions, do not forget to create proper
--    environment (use env.beginFun) and register arguments
--    (use env.addArg).
-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
   fun label (lab, labUsed) {
      if labUsed then singletonBuffer(LABEL(lab)) else emptyBuffer() fi
   }
   fun compileMany (lab, env, exprs) {
      case exprs of
        {e}   -> compile(lab, env, e)
      | e: es -> case env.genLabel of
                   [eLab, env] -> case compile(eLab, env, e) of
                                    [eUsed, env, eCode] -> case compileMany(lab, env, es) of
                                                             [labUsed, env, esCode] -> [labUsed, env, eCode <+> label(eLab,
                                                                                                        eUsed) <+> esCode]
                                                           esac
                                  esac
                 esac
      esac
   }
   fun compile (l, env, stmt) {
      case stmt of
        Skip            -> [false, env, emptyBuffer()]
      | Var(x)          -> [false, env, singletonBuffer(LD(lookupVar(env, x)))]
      | Ref(x)          -> [false, env, singletonBuffer(LDA(lookupVar(env, x)))]
      | Const(n)        -> [false, env, singletonBuffer(CONST(n))]
      | Read(x)         -> [false, env, emptyBuffer() <+ READ <+ ST(lookupVar(env, x)) <+ DROP]
      | Write(e)        -> let [l1, env] = genLabel(env) in
                              let [l2, env, ec] = compile(l1, env, e) in [false, env, ec <+> label(l1, l2) <+ WRITE]
      | Binop(s, l, r)  -> let [l1, l2, env] = genLabels(env, 2) in
                              let [l3, env, lc] = compile(l1, env, l) in
                                 let [l4, env, rc] = compile(l2, env, r) in
                                    [false, env, lc <+> label(l1, l3) <+> rc <+> label(l2, l4) <+ BINOP(s)]
      | Assn(x, e)      -> let [l1, l3, env] = genLabels(env, 2) in
                              let [l2, env, xc] = compile(l1, env, x) in
                                 let [l4, env, ec] = compile(l3, env, e) in
                                    [false, env, xc <+> label(l1, l2) <+> ec <+> label(l3, l4) <+ STI]
      | Assn(Ref(x), e) -> let [l1, env] = genLabel(env) in
                              let [l2, env, ec] = compile(l1, env, e) in
                                 [false, env, ec <+> label(l1, l2) <+ ST(lookupVar(env, x))]
      | Seq(s1, s2)     -> let [l1, env] = genLabel(env) in
                              let [l2, env, c1] = compile(l1, env, s1) in
                                 let [l3, env, c2] = compile(l, env, s2) in [l3, env, c1 <+> label(l1, l2) <+> c2]
      | If(con, t, f)   -> let [l1, l2, env] = genLabels(env, 2) in
                              let [l3, env, ccon] = compile(l2, env, con) in
                                 let [_, env, ct] = compile(l, env, t) in
                                    let [_, env, cf] = compile(l, env, f) in
                                       [true, env, ccon <+> label(l2, l3) <+ CJMP("z",
                                                        l1) <+> ct <+ JMP(l) <+ LABEL(l1) <+> cf]
      | While(con, b)   -> compile(l, env, If(con, DoWhile(b, con), Skip))
      | DoWhile(b, con) -> let [l1, l2, l3, env] = genLabels(env, 3) in
                              let [l4, env, ccon] = compile(l3, env, con) in
                                 let [l5, env, cb] = compile(l1, env, b) in
                                    [false, env, label(l2, true) <+> cb <+> label(l1, l5) <+> ccon <+> label(l3,
                                                   l4) <+ CJMP("nz", l2)]
      | Ignore(e)       -> let [l1, env] = genLabel(env) in
                              let [l2, env, c] = compile(l1, env, e) in [false, env, c <+> label(l1, l2) <+ DROP]
      | Scope(d, e)     -> let env = beginScope(env) in
                              let env = foldl(fun (env, def) {
                                             case def of
                                               Var(n)       -> addVars(env, n)
                                             | Fun(n, a, b) -> let [l, env] = genFunLabel(env, n) in
                                                                  addFun(env, n, l, size(a))
                                             esac
                                          }, env, d) in
                                 let env = foldl(fun (env, d) {
                                                case d of
                                                  Var(_)       -> env
                                                | Fun(n, a, b) -> let [l, env] = genFunLabel(env, n) in
                                                                     rememberFun(env, l, a, b)
                                                esac
                                             }, env, d) in
                                    let code = if isGlobal(env)
                                               then foldl(fun (code, def) {
                                                         case def of
                                                           Var(n) -> foldl(fun (code, x) {code <+ GLOBAL(x)}, code, n)
                                                         | _      -> code
                                                         esac
                                                      }, emptyBuffer(), d)
                                               else emptyBuffer()
                                               fi in let [l, env, c] = compile(l, env, e) in [l, endScope(env), code <+> c]
      | Call(n, a)      -> case a of
                             {} -> let Fun(n, a) = lookupFun(env, n) in [false, env, singletonBuffer(CALL(n, a))]
                           | _  -> let [l1, env] = genLabel(env) in
                                      let [l2, env, c] = compileMany(l1, env, a) in
                                         let Fun(n, a) = lookupFun(env, n) in
                                            [false, env, (c <+> label(l1, l2)) <+ CALL(n, a)]
                           esac
      esac
   }
   fun compileFunctions (env, main) {
      fun iterate (env, funList) {
         case funList of
           {}                            -> case getFuns(env) of
                                              [{}, env] -> emptyBuffer()
                                            | [fs, env] -> iterate(env, fs)
                                            esac
         | Fun(f, args, body, state): fs -> case genLabel(addArgs(beginFun(env, state), args)) of
                                              [endLab, env] -> case compile(endLab, env, body) of
                                                                 [endUsed, env, code] -> singletonBuffer(LABEL(f)) <+
                                                                                         BEGIN(f,
                                                                                               args.size,
                                                                                               getLocals(env)) <+>
                                                                                         code <+>
                                                                                         label(endLab, endUsed) <+
                                                                                         END <+>
                                                                                         iterate(env, fs)
                                                               esac
                                            esac
         esac
      }
      
      main <+> iterate(env, {})
   }
   
   case initCompEnv().genLabel of
     [endLab, env] -> case compile(endLab, env, stmt) of
                        [endLabUsed, env, code] -> getBuffer $ compileFunctions(env,
                                                     singletonBuffer(LABEL("main")) <+ BEGIN("main",
                                                           0,
                                                           getLocals(env)) <+> code <+> label(endLab, endLabUsed) <+ END)
                      esac
   esac
}