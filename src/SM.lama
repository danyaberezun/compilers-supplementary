-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Builtins;
import Buffer;

-- data SMLocation =
--   Arg (i) -- i'th function argument
-- | Loc (i) -- i'th local variable
-- | Glb (x) -- global variable with name x

-- Renders SMLocation to string.
-- \param loc : SMLocation
-- \return string
fun showSMLocation (loc) {
  case loc of
    Arg (i) -> sprintf ("arg[%d]", i)
  | Loc (i) -> sprintf ("loc[%d]", i)
  | Glb (x) -> x
  esac
}

-- data SMInstruction =
-- | BINOP (op)
-- | LD (loc)
-- | LDA (loc)
-- | ST (x)
-- | STI
-- | SEXP (s, n)
-- | CONST (n)
-- | LABEL (label)
-- | JMP (label)
-- | CJMP (cond, label)
-- | CALL (functionLabel, argumentsNo)
-- | BEGIN (functionLabel, argumentsNo, localsNo)
-- | GLOBAL (x)
-- | END
-- | DUP
-- | DROP
-- | STRING (s)
-- | ARRAY (n)
-- | STA
-- | ELEM
-- | BUILTIN (f, n)

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    BINOP  (s)       -> sprintf ("BINOP %s", s)
  | LD     (x)       -> sprintf ("LD %s", showSMLocation (x))
  | LDA    (x)       -> sprintf ("LDA %s", showSMLocation (x))
  | ST     (x)       -> sprintf ("ST %s", showSMLocation (x))
  | STI              -> "STI"
  | SEXP   (s, n)    -> sprintf ("SEXP ""%s"", %d", s, n)
  | CONST  (n)       -> sprintf ("CONST %d", n)
  | LABEL  (s)       -> sprintf ("LABEL %s", s)
  | JMP    (l)       -> sprintf ("JMP %s", l)
  | CJMP   (c, l)    -> sprintf ("CJMP %s, %s", c, l)
  | CALL   (f, n)    -> sprintf ("CALL %s, %d", f, n)
  | BEGIN  (f, a, l) -> sprintf ("BEGIN %s, %d, %d", f, a, l)
  | GLOBAL (x)       -> sprintf ("GLOBAL %s", x)
  | END              -> sprintf ("END")
  | DUP              -> "DUP"
  | DROP             -> "DROP"
  | STRING (s)       -> sprintf ("STRING ""%s""", s)
  | ARRAY  (n)       -> sprintf ("ARRAY %d", n)
  | STA              -> "STA"
  | ELEM             -> "ELEM"
  | BUILTIN (f, n)   -> sprintf ("BUILTIN %s, %d", f, n)
  esac
}

-- type SMProgram = List SMInstruction
--
-- The order is from the first instruction to the last.

-- Renders SMProgram to string.
-- \param prg : SMProgram
-- \return string
public fun showSM (prg) {
  stringcat (map (fun (i) {showSMInsn (i) ++ "\n"}, prg))
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | BEGIN (functionLabel, _, _) : tl -> rec ([addMap (m, functionLabel, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Given a label, returns the subprogram of this label.
--
-- \param env : SMEvalEnv -- evaluation environment
-- \param lab : string -- label name
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- data SMStack = ?

-- data SMControlStack

-- data SMLocalState = [List Int, List Int],
-- where first is arguments, and second is local variables

fun smLocalStateCreate (argNo, locNo) {
  [initArray (argNo, fun (_) {0}), initArray (locNo, fun (_) {0})]
}

-- data SMGlobalState = String -> Int

fun smGlobalStateEmpty (name) {
  failure ("name '%s' is undefined", name)
}

fun smGlobalStateAssign (state, name, value) {
  fun (x) {
    if compare (x, name) == 0
      then value
      else state (x)
    fi
  }
}

fun smStackPopN (n, stack) {
  var arr = makeArray (n);
  var currentStack = stack;
  for var index; index := n - 1, index >= 0, index := index - 1 do
    case currentStack of value : tail ->
      arr [index] := value;
      currentStack := tail
    esac
  od;
  [arr, currentStack]
}

-- data SMConfiguration = SMConfiguration (SMStack, SMControlStack, SMLocalState, World)

-- \param env : SMEvalEnv -- evaluation environment
-- \return (SMConfiguration, SMProgram) -> SMConfiguration
fun evalImpl (env) {

  -- data ProgramStep = Forward | JumpTo (label) | Stop | GoToInsts (nextInsts)
  
  -- data SValue = Int
  --             | String
  --             | [Value]
  --             | Sexp (Uident, [Value])
  --             | LocRef (loc)

  -- globalState : SMGlobalState
  var globalState = ref (smGlobalStateEmpty);

  -- Looks up value for given SM location in given local, or in the global state.
  --
  -- \param localState : SMLocalState
  -- \param loc : SMLocation
  -- \return Int
  fun lookup (localState@[args, locals], loc) {
    case loc of
      Arg (argIdx) -> args[argIdx]
    | Loc (localIdx) -> locals[localIdx]
    | Glb (x) -> deref (globalState) (x)
    esac
  }

  -- Assigns a value to given SM location.
  --
  -- \param localState : SMLocalState
  -- \param loc : SMLocation
  -- \param value : Int
  fun assign (localState@[args, locals], loc, value) {
    case loc of
      Arg (argIdx) ->
        args[argIdx] := value
    | Loc (localIdx) ->
        locals[localIdx] := value
    | Glb (x) ->
        globalState ::= smGlobalStateAssign (deref (globalState), x, value)
    esac
  }

  -- \param config : SMConfiguration
  -- \param inst : SMInstruction
  -- \param nextInsts : List SMInstruction
  fun evalInst (config@[stack, controlStack, localState, world], inst, nextInsts) {
    --printf ("SM.evalInst inst=%s\n", showSMInsn (inst));
    --printf ("stack: %s\n", stack.string);
    case inst of
      BINOP (op) ->
        case stack of (rhs@#val) : (lhs@#val) : stackTail ->
          var result = evalOp (op, lhs, rhs);
          [Forward, [result : stackTail, controlStack, localState, world]]
        esac
    | LD (loc) ->
        [Forward, [lookup (localState, loc) : stack, controlStack, localState, world]]
    | LDA (loc) ->
        [Forward, [LocRef (loc) : stack, controlStack, localState, world]]
    | ST (loc) ->
        case stack of value : stackTail ->
          assign (localState, loc, value);
          [Forward, config]
        esac
    | STI ->
        case stack of value : ref : stackTail ->
          case ref of
            LocRef (loc) ->
              assign (localState, loc, value)
          | ElemRef (arr, index) ->
              arr [index] := value
          esac;
          [Forward, [value : stackTail, controlStack, localState, world]]
        esac
    | SEXP (uident, n) ->
        case smStackPopN (n, stack) of [elements, stack]->
          [Forward, [Sexp (uident, elements) : stack, controlStack, localState, world]]
        esac
    | CONST (n) ->
        [Forward, [n : stack, controlStack, localState, world]]
    | LABEL (_) ->
        [Forward, config]
    | JMP (label) ->
        [JumpTo (label), config]
    | CJMP (condition, label) ->
        case stack of (stackTop@#val) : stackTail ->
          var programStep = case condition of
            "z" ->
              if (stackTop == 0)
                then JumpTo (label)
                else Forward
              fi
          | "nz" ->
              if (stackTop != 0)
                then JumpTo (label)
                else Forward
              fi
          esac;
          [programStep, [stackTail, controlStack, localState, world]]
        esac
    | CALL ("$read", 0) ->
        case readWorld (world) of [value, world] ->
          [Forward, [value : stack, controlStack, localState, world]]
        esac
    | CALL ("$write", 1) ->
        case stack of (n@#val) : stack ->
          [Forward, [0 : stack, controlStack, localState, writeWorld (n, world)]]
        esac
    | CALL ("$length", 1) ->
        case stack of container : stack ->
          var len = case container of
            Sexp (_, elements) -> length (elements)
          | _ -> length (container)
          esac;
          [Forward, [len : stack, controlStack, localState, world]]
        esac
    | CALL (functionLabel, argNo) ->
        [JumpTo (functionLabel), [stack, [localState, nextInsts] : controlStack, localState, world]]
    | BEGIN (funcName, argNo, localNo) ->
        case smStackPopN (argNo, stack) of [args, stack] ->
          var localState = [args, initArray (localNo, fun (_) {0})];
          [Forward, [stack, controlStack, localState, world]]
        esac
    | GLOBAL (x) ->
        assign (localState, Glb (x), 0);
        [Forward, config]
    | END ->
        case controlStack of
          [localState, nextInsts] : controlStack ->
            [GoToInsts (nextInsts), [stack, controlStack, localState, world]]
        | {} ->
            [Stop, config]
        esac
    | DUP ->
        case stack of stackTop : stackTail ->
          [Forward, [stackTop : stack, controlStack, localState, world]]
        esac
    | DROP ->
        case stack of _ : stackTail ->
          [Forward, [stackTail, controlStack, localState, world]]
        esac
    | STRING (s) ->
        [Forward, [s : stack, controlStack, localState, world]]
    | ARRAY (n) ->
        case smStackPopN (n, stack) of [arr, stack] ->
          [Forward, [arr : stack, controlStack, localState, world]]
        esac
    | STA ->
        case stack of value : (index@#val) : container : tail ->
          case container of
            arr@#array -> arr [index] := value
          | s@#str -> s [index] := value
          | Sexp (_, elements) -> elements [index] := value
          esac;
          [Forward, [value : tail, controlStack, localState, world]]
        esac
    | ELEM ->
        case stack of (index@#val) : container : stack ->
          var elem = case container of
            arr@#array -> arr [index]
          | s@#str -> s [index]
          | Sexp (_, elements) -> elements [index]
          esac;
          [Forward, [elem : stack, controlStack, localState, world]]
        esac
    | BUILTIN (_, _) -> failure ("wat")
    esac
  }

  fun eval (config, program) {
    case program of
      {} -> config
    | firstInst : nextInsts ->
      case evalInst (config, firstInst, nextInsts) of [programStep, config] ->
        var subprogram = case programStep of
          Forward -> nextInsts
        | JumpTo (label) -> fromLabel (env, label)
        | Stop -> {}
        | GoToInsts (nextInsts) -> nextInsts
        esac;
        eval (config, subprogram)
      esac
    esac
  }

  eval
}

-- Stack machine interpreter. 
--
-- \param env : SMEvalEnv -- evaluation environment
-- \param config : SMConfiguration -- initial SM configuration
-- \param program : SMProgram -- the SM program to evaluate
-- \return SMConfiguration -- final SM configuration
fun eval (env, config, program) {
  var impl = evalImpl (env);
  impl (config, program)
}

-- Stack machine interpreter.
--
-- \param input : string -- program input
-- \param program : SMProgram -- the SM program to interpret
-- \return string -- program output
public fun evalSM (input, program) {
  --printf ("SM.evalSM\n%s\n", showSM (program));
  getOutput $ eval (
    initEvalEnv (program),
    [{}, {}, smLocalStateCreate (0, 0), createWorld (input)],
    program
  )[3]
}

-- Create a label object, which keeps a flag, indicating if this label has been used or not.
-- If this flag is false, then emitting LABEL instruction won't be necessary.
--
-- \param labelName : String
-- \return SMLabel
fun makeLabel (labelName) {
  var labelUsed = ref (false);

  fun use () {
    labelUsed ::= true
  }

  fun compile () {
    if deref (labelUsed)
      then getInst ()
      else emptyBuffer ()
    fi
  }

  fun getInst () {
    use ();
    singletonBuffer (LABEL (labelName))
  }

  fun makeJmp () {
    use ();
    singletonBuffer (JMP (labelName))
  }

  fun makeCJmp (c) {
    use ();
    singletonBuffer (CJMP (c, labelName))
  }

  [use, compile, getInst, makeJmp, makeCJmp]
}

fun labelUse (label) {
  label[0] ()
}

fun labelCompile (label) {
  label[1] ()
}

fun labelGetInst (label) {
  label[2] ()
}

fun labelMakeJmp (label) {
  label[3] ()
}

fun labelMakeCJmp (label, c) {
  label[4] (c)
}

-- data SMCompFunc = Func String (List String) Expr State

-- \return SMCompilationEnv
fun cEnvCreate () {
  -- nextLabelNo : Ref Int
  var nextLabelNo = ref (0);

  -- scopeDepth : Ref Int
  var scopeDepth = ref (0);

  -- state : Ref State
  var state = ref (emptyState ());

  -- argumentsNo : Ref Int
  var argumentsNo = ref (0);

  -- localsNo : Ref Int
  var localsNo = ref (0);

  -- functions : Ref (List SMCompFunc) 
  var functions = ref ({});

  fun genLabel () {
    var labelNo = deref (nextLabelNo);
    var label = sprintf ("L%d", labelNo);
    nextLabelNo ::= labelNo + 1;
    makeLabel (label)
  }

  fun beginScope () {
    scopeDepth ::= deref (scopeDepth) + 1;
    state ::= enterScope (deref (state))
  }

  fun endScope () {
    scopeDepth ::= deref (scopeDepth) - 1;
    state ::= leaveScope (deref (state))
  }

  fun addArgument (name) {
    var argumentIdx = deref (argumentsNo);
    argumentsNo ::= argumentIdx + 1;
    state ::= addName (deref (state), name, Arg (argumentIdx))
  }

  fun addVariable (name) {
    if deref (scopeDepth) == 2
    then
      state ::= addName (deref (state), name, Glb (name))
    else
      var localIdx = deref (localsNo);
      localsNo ::= localIdx + 1;
      state ::= addName (deref (state), name, Loc (localIdx))
    fi
  }

  fun takeFunctions () {
    var result = deref (functions);
    functions ::= {};
    result
  }

  fun beginFunction (function@Fun (functionLabel, params, bodyExpr, functionState)) {
    --printf ("SM.beginFunction %s\n", function.string);
    scopeDepth ::= 2;
    state ::= enterFunction (functionState);
    argumentsNo ::= 0;
    localsNo ::= 0;
    iter (fun (paramName) {
      addArgument (paramName)
    }, params)
  }

  fun lookupVariable (identifier) {
    case lookup (deref (state), identifier) of
      Fun (_, _) -> failure ("Identifier ""%s"" does not designate a variable", identifier)
    | v -> v
    esac
  }

  fun addFunction (functionName, functionLabel, argumentsNo) {
    state ::= addName (deref (state), functionName, Fun (functionLabel, argumentsNo))
  }

  fun genFunctionLabel (functionName) {
    if deref (scopeDepth) > 2 then
      var functionLabelNo = deref (nextLabelNo);
      nextLabelNo ::= functionLabelNo + 1;
      sprintf ("L%s_%d", functionName, functionLabelNo)
    else
      sprintf ("L%s", functionName)
    fi
  }

  fun registerFunction (functionLabel, parameterNames, bodyExpr) {
    functions ::= Fun (functionLabel, parameterNames, bodyExpr, deref (state)) : deref (functions)
  }

  fun lookupFunction (identifier) {
    case lookup (deref (state), identifier) of
      Fun (functionLabel, argumentsNo) -> 
        Fun (functionLabel, argumentsNo)
    | _ -> failure ("Function %s undefined", identifier)
    esac
  }

  [
    genLabel,
    scopeDepth,
    beginScope,
    endScope,
    addArgument,
    addVariable,
    takeFunctions,
    beginFunction,
    lookupVariable,
    addFunction,
    genFunctionLabel,
    registerFunction,
    lookupFunction,
    localsNo
  ]
}

-- Generate a new label.
-- 
-- \param env : SMCompilationEnv
-- \return SMLabel
fun cEnvGenLabel (env) {
  env [0] ()
}

-- Check if the current scope is the global scope.
--
-- \param env : SMCompilationEnv
-- \return Bool
fun cEnvIsGlobal (env) {
  deref (env [1]) == 2
}

-- Enter a new scope.
--
-- \param env : SMCompilationEnv
fun cEnvBeginScope (env) {
  env [2] ()
}

-- Leave the current scope.
--
-- \param env : SMCompilationEnv
fun cEnvEndScope (env) {
  env [3] ()
}

-- Add an argument for the current function.
--
-- \param env : SMCompilationEnv
-- \param name : String -- the name of the argument.
fun cEnvAddArgument (env, name) {
  env [4] (name)
}

-- Add a variable to the current scope.
-- If the current scope is the global scope, a global variable will be added.
-- Otherwise, a local variable for the current function is added.
--
-- \param env : SMCompilationEnv
-- \param identifier : String -- variable name.
fun cEnvAddVariable (env, identifier) {
  env [5] (identifier)
}

-- Add several variables to the current scope.
--
-- \param env : SMCompilationEnv
-- \param identifiers : List String
fun cEnvAddVariables (env, identifiers) {
  iter (fun (identifier) { 
    cEnvAddVariable (env, identifier)
  }, identifiers)
}

-- Get all registered functions and clear the functions registry list.
--
-- \param env : SMCompilationEnv
-- \return List SMCompFunc
fun cEnvTakeFunctions (env) {
  env [6] ()
}

-- Prepare compilation environment for compiling a new function.
--
-- \param env : SMCompilationEnv
-- \param function : SMCompFunc
fun cEnvBeginFunction (env, function) {
  env [7] (function)
}

-- Lookup a variable.
--
-- \param env : SMCompilationEnv
-- \param identifier : String -- name of the variable.
-- \return SMLocation -- location of the variable.
fun cEnvLookupVariable (env, identifier) {
  env [8] (identifier)
}

-- Declare a function in the current scope.
--
-- \param env : SMCompilationEnv
-- \param functionName : String
-- \param functionLabel : String
-- \param argumentsNo : Int
fun cEnvAddFunction (env, functionName, functionLabel, argumentsNo) {
  env [9] (functionName, functionLabel, argumentsNo)
}

-- Create a label for a function.
--
-- \param env : SMCompilationEnv
-- \param functionName : String
-- \return String -- name of the created label.
fun cEnvGenFunctionLabel (env, functionName) {
  env [10] (functionName)
}

-- \param env : SMCompilationEnv
-- \param functionLabel : String
-- \param parameterNames : List String
-- \param bodyExpr : Expr
fun cEnvRegisterFunction (env, functionLabel, parameterNames, bodyExpr) {
  env [11] (functionLabel, parameterNames, bodyExpr)
}

-- Lookup a function.
--
-- \param env : SMCompilationEnv
-- \param identifier : String -- function name.
-- \return Fun (functionLabel, argumentsNo)
fun cEnvLookupFunction (env, identifier) {
  env [12] (identifier)
}

-- Get the total number of local variables in the current function.
--
-- \param env : SMCompilationEnv
-- \return Int
fun cEnvGetLocalsNo (env) {
  deref (env [13])
}

-- Compile a Lama expression into stack machine code.
--
-- \param root -- root of the Lama AST
-- \return SMProgram -- compiled SM program
public fun compileSM (root) {
  -- env : SMCompilationEnv
  var env = cEnvCreate ();

  -- type SMCode = Buffer SMInstruction

  fun compileDefinitions (definitions) {
    var code = ref (emptyBuffer ());
    var functionsToRegister = ref ({});

    -- Declare variables and functions
    iter (fun (definition) {
      case definition of
        Var (identifiers) ->
          if cEnvIsGlobal (env) then 
            iter (fun (identifier) {
              code ::= deref (code) <+ GLOBAL (identifier)
            }, identifiers)
          fi;
          cEnvAddVariables (env, identifiers)
      | Fun (functionName, parameters, bodyExpr) ->
          var functionLabel = cEnvGenFunctionLabel (env, functionName);
          cEnvAddFunction (env, functionName, functionLabel, size (parameters));
          functionsToRegister ::= [functionLabel, parameters, bodyExpr] : deref (functionsToRegister)
      esac
    }, definitions);
    
    -- Register functions
    iter (fun ([functionLabel, parameters, bodyExpr]) {
      cEnvRegisterFunction (env, functionLabel, parameters, bodyExpr)
    }, deref (functionsToRegister));

    deref (code)
  }

  fun compileExpressionList (expressions) {
    var code = ref (emptyBuffer ());
    iter (fun (expr) {
      var endLabel = cEnvGenLabel (env);
      code ::= deref (code)
        <+> compile (endLabel, expr)
        <+> labelCompile (endLabel)
    }, expressions);
    deref (code)
  }

  -- Compile a Lama expression into stack machine code.
  --
  -- \param endLabel : SMLabel
  -- \param expr -- Lama expression
  -- \return SMCode
  fun compile (endLabel, expr) {
    --printf ("SM.compile expr=%s\n", expr.string);
    case expr of
      Assn (e_var, e_val) ->
        var stInst = case e_var of
          ElemRef (_, _) -> STA
        | _ -> STI
        esac;
        compileExpressionList ({e_var, e_val})
          <+ stInst
    | Set (identifier, e_val) ->
        compileExpressionList ({e_val})
          <+ ST (cEnvLookupVariable (env, identifier))
    | Seq (e1, e2) ->
        var e2Label = cEnvGenLabel (env);
        compile (e2Label, e1)
          <+> labelCompile (e2Label)
          <+> compile (endLabel, e2)
    | Skip ->
        emptyBuffer ()
    | If (condE, thenE, elseE) ->
        var checkLabel = cEnvGenLabel (env);
        var thenLabel = cEnvGenLabel (env);
        compile (checkLabel, condE)
          <+> labelCompile (checkLabel)
          <+> labelMakeCJmp (thenLabel, "nz")
          <+> compile (endLabel, elseE)
          <+> labelMakeJmp (endLabel)
          <+> labelGetInst (thenLabel)
          <+> compile (endLabel, thenE)
    | While (condE, bodyE) ->
        var condLabel = cEnvGenLabel (env);
        var checkLabel = cEnvGenLabel (env);
        labelGetInst (condLabel)
          <+> compile (checkLabel, condE)
          <+> labelCompile (checkLabel)
          <+> labelMakeCJmp (endLabel, "z")
          <+> compile (condLabel, bodyE)
          <+> labelMakeJmp (condLabel)
    | DoWhile (bodyE, condE) ->
        var bodyLabel = cEnvGenLabel (env);
        var condLabel = cEnvGenLabel (env);
        var checkLabel = cEnvGenLabel (env);
        labelGetInst (bodyLabel)
          <+> compile (condLabel, bodyE)
          <+> labelCompile (condLabel)
          <+> compile (checkLabel, condE)
          <+> labelCompile (checkLabel)
          <+> labelMakeCJmp (bodyLabel, "nz")
    | Var (identifier) ->
        singletonBuffer (LD (cEnvLookupVariable (env, identifier)))
    | Ref (identifier) ->
        singletonBuffer (LDA (cEnvLookupVariable (env, identifier)))
    | Const (n) ->
        singletonBuffer (CONST (n))
    | Binop (op, lhsE, rhsE) ->
        var rhsLabel = cEnvGenLabel (env);
        var opLabel = cEnvGenLabel (env);
        compile (rhsLabel, lhsE)
          <+> labelCompile (rhsLabel)
          <+> compile (opLabel, rhsE)
          <+> labelCompile (opLabel)
          <+ BINOP (op)
    | Scope (definitions, expr) ->
        cEnvBeginScope (env);
        (
          var code = compileDefinitions (definitions)
            <+> compile (endLabel, expr);
          cEnvEndScope (env);
          code
        )
    | Call (functionName, argumentsE) ->
        var code = compileExpressionList (argumentsE);
        case cEnvLookupFunction (env, functionName) of Fun (functionLabel, argumentsNo) ->
          code <+ CALL (functionLabel, argumentsNo)
        esac
    | Ignore (expr) ->
        var ignoreLabel = cEnvGenLabel (env);
        compile (ignoreLabel, expr)
          <+> labelCompile (ignoreLabel)
          <+ DROP
    | String (s) ->
        singletonBuffer (STRING (s))
    | Array (e_elements) ->
        var code = compileExpressionList (e_elements);
        code <+ ARRAY (size (e_elements))
    | Sexp (uident, e_elements) ->
        var code = compileExpressionList (e_elements);
        code <+ SEXP (uident, size (e_elements))
    | Elem (e_container, e_index) ->
        compileExpressionList ({e_container, e_index})
          <+ ELEM
    | ElemRef (e_container, e_index) ->
        compileExpressionList ({e_container, e_index})
    esac
  }

  -- Compile a function (which also includes the "main" function as the global program).
  --
  -- When a nested function definition is encountered, it is also compiled
  -- and appended after this functions code.
  --
  -- \param root -- top-level Lama expression of this function.
  -- \param functionLabel : String -- label of this function.
  -- \param argumentsNo : Int -- number of arguments of this function.
  -- \return SMCode -- compiled stack machine code of this function.
  fun compileFunction (root, functionLabel, argumentsNo) {
    -- Force root expression to be a Scope expression
    --var x = printf ("SM.compileFunction %s argumentsNo=%s\n%s\n", functionLabel, argumentsNo.string, root.string);
    var reifiedRoot = case root of
      Scope (_, _) -> root
    | _ -> Scope ({}, root)
    esac;
    var endLabel = cEnvGenLabel (env);
    var code =
      compile (endLabel, reifiedRoot)
      <+> labelCompile (endLabel)
      <+ END;
    var registeredFunctions = cEnvTakeFunctions (env);
    code := singletonBuffer (BEGIN (functionLabel, argumentsNo, cEnvGetLocalsNo (env)))
      <+> code;
    code := ref (code);
    iter (fun (function) {
      case function of Fun (functionLabel, args, body, state) ->
        var bodyCode;
        var localsNo;
        cEnvBeginFunction (env, function);
        bodyCode := compileFunction (body, functionLabel, size (args));
        code ::= deref (code)
          <+> bodyCode
      esac
    }, registeredFunctions);
    deref (code)
  }

  var code;
  --printf ("SM.compileSM\n%s\n", root.string);
  cEnvBeginScope ();
  cEnvAddFunction (env, "read", "$read", 0);
  cEnvAddFunction (env, "write", "$write", 1);
  cEnvAddFunction (env, "length", "$length", 1);
  code := compileFunction (root, "main", 0);
  getBuffer (code)
}


