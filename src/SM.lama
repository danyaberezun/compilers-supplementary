-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  case insns of
    {} -> c
  | insn : insnRest ->
    eval (evalInstruction (c, insn), insnRest)
  esac
}

fun evalInstruction ([stack, s, w], insn) {
  case insn of
    WRITE ->
    case stack of
      n : stackRest -> [ stackRest, s, writeWorld (n, w) ]
    esac
  | CONST (n) -> [n : stack, s, w]
  | BINOP (op) ->
    case stack of
      r : l : stackRest -> [ evalBinop (op, l, r) : stackRest, s, w ]
    esac
  | LD (x) -> [ (s (x)) : stack, s, w ]
  | ST (x) ->
      case stack of
        z : stackn -> [stackn, s <- [x, z], w]
      esac
  | READ ->
      case readWorld (w) of
        [v, nw] -> [v : stack, s, nw]
      esac
  | _ -> failure ("%s instruction not implemented", insn.string)
  esac
}

fun evalBinop(op, l, r) {
    case op of
      "*" -> l * r
    | "+" -> l + r
    | "-" -> l - r
    | "/" -> l / r
    | "%" -> l % r
    | "<" -> l < r
    | "<=" -> l <= r
    | "==" -> l == r
    | "!=" -> l != r
    | ">=" -> l >= r
    | ">" -> l > r
    | _ -> failure ("%s binop not implemented", op)
    esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
  getBuffer (compileExprBuf (expr))
}

fun compileExprBuf (expr) {
  case expr of
    Const (n) -> singletonBuffer (CONST (n))
  | Var (x) -> singletonBuffer (LD (x))
  | Binop (op, l, r) ->
      compileExprBuf (l) <+>
      compileExprBuf (r) <+>
      singletonBuffer (BINOP (op))
  | _ -> failure ("%s compileExpr not implemented", expr.string)
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  getBuffer (compileSMBuf (stmt))
}

fun compileSMBuf (stmt) {
  case stmt of
    Write (e) -> compileExprBuf (e) <+> singletonBuffer (WRITE)
  | Seq (s1, s2) -> compileSMBuf (s1) <+> compileSMBuf (s2)
  | Read (x) ->
    singletonBuffer (READ) <+>
    singletonBuffer (ST (x))
  | Assn (x, e) ->
    compileExprBuf (e) <+>
    singletonBuffer (ST (x))
  | _ -> failure ("%s compileSM not implemented", stmt.string)
  esac
}
