-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import SM;
import Collection;
import List;
import Array;
import Buffer;
import Fun;
import Manifest;

fun min (x, y) {
  if x > y then y else x fi
}

fun max (x, y) {
  if x > y then x else y fi
}

-- Assembler language interface
-- The registers:
var regs = ["%rdi", "%rsi", "%rdx", "%rcx",
            "%r8" , "%r9" , "%r10", "%r11",
	    "%r12", "%r13", "%r14", "%r15",
	    "%rbx", "%rax", "%rbp", "%rsp"];

-- We can not freely operate with all register; only with 13 by now;
-- we also notify that the 6 first register are used to
-- pass arguments to a function
var nRegs    = regs.length - 4,
    nRegArgs = 6;

-- For convenience we define the following synonyms for the registers: 
var rdi = R (0),
    rsi = R (1),
    rdx = R (2),
    rcx = R (3),
    r8  = R (4),
    r9  = R (5),
    r10 = R (6),
    r11 = R (7),
    r12 = R (8),
    r13 = R (9),
    r14 = R (10),
    r15 = R (11),
    rbx = R (12),
    rax = R (13),
    rbp = R (14),
    rsp = R (15);

-- Lama 1.3: crash after start if al, ah, dl, dh are directly initialized by string literals
var regs8 = ["%al", "%ah", "%dl", "%dh"];
var al = regs8[0],
    ah = regs8[1],
    dl = regs8[2],
    dh = regs8[3];

-- We need to know the word size to calculate offsets correctly
var wordSize = 8;

-- We need to distinguish the following operand types: 
--    R (int)        -- hard register                    
--    S (int)        -- a position on the hardware stack 
--    M (string)     -- a named memory location          
--    L (int/string) -- an immediate operand             
--    I (int, opnd)  -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)
                                                               
-- Machine instruction printer
fun insnString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addq"
    | "-"   -> "subq"
    | "*"   -> "imulq"
    | "&&"  -> "andq"
    | "!!"  -> "orq" 
    | "^"   -> "xorq"
    | "cmp" -> "cmpq"
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i)      -> regs [i]
    | S (i)      -> if i >= 0
                    then sprintf ("-%d(%%rbp)", (i+1) * wordSize)
                    else sprintf ("%d(%%rbp)", wordSize * 2 + (-1-i) * wordSize)
                    fi

    | M (x)      -> sprintf ("%s(%rip)", x)
    | L (i@#val) -> sprintf ("$%d", i)
    | L (i@#str) -> sprintf ("%s", i)
    | I (0, x)   -> sprintf ("(%s)", opndString (x))
    | I (n, x)   -> sprintf ("%d(%s)", n, opndString (x))
    esac
  }
  
  case insn of
    Cltd               -> "\tcqo\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | Sal   (s)          -> sprintf ("\tsalq\t%s\n", s)
  | IDiv  (s1)         -> sprintf ("\tidivq\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovq\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Lea   (s1, s2)     -> sprintf ("\tleaq\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushq\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopq\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", c, l)
  | Meta  (m)          -> m
  esac
}

-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names
--    a barrier condition (set up right after an unconditional jump is interpreter)
--    a stack map which maps labels to symbolic stacks

fun makeEnv (stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals) {
  -- Returns an internal name for a global variable
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", string (stack), stackSlots, string (elements (globals)))
  }
  
  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun alloc () {
    case 
      case stack of
        {}        -> [rdi, 0]
      | S (n) : _ -> [S (n+1), n+2]
      | R (n) : _ -> if n < nRegs then [R (n+1), stackSlots] else [S (nLocals), nLocals + 1] fi
      | _         -> [S (nLocals), nLocals + 1]
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals, barrier, stackMap, fLabel, nLocals)]esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals)
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  fun pop () {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an undated environment
  fun pop2 () {
    case stack of
      x : y : stack -> [x, y, makeEnv (stack, stackSlots, globals, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Peeks the top of the symbolic stack
  fun peek () {
    fst (stack)
  }
  
  -- Adds a global variable; returns an updated environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)), barrier, stackMap, fLabel, nLocals)
  }

  -- References an allocation
  fun loc (alloc) {
    case alloc of
      Glb (x) -> M (globalName (x))
    | Arg (i) -> if i < nRegArgs then R (i) else S (-1-(i - nRegArgs)) fi
    | Loc (i) -> S (i)
    esac
  }
  
  -- Gets a list of global variables from the environment
  fun getGlobals () {
    elements (globals)
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize () {
    stackSlots
  }

  -- Gets barrier condition
  fun isBarrier () {
    barrier
  }

  -- Sets barrier condition
  fun setBarrier () {
    makeEnv (stack, stackSlots, globals, true, stackMap, fLabel, nLocals)
  }

  -- Associates the current symbolic state with a label
  fun setStack (l) {
    makeEnv (stack, stackSlots, globals, false, addMap (stackMap, l, stack), fLabel, nLocals)
  }

  -- Retrieves a stack for a label
  fun retrieveStack (l) {
    case findMap (stackMap, l) of
      None         -> makeEnv (stack, stackSlots, globals, false, stackMap, fLabel, nLocals)
    | Some (stack) -> makeEnv (stack, stackSlots, globals, false, stackMap, fLabel, nLocals)
    esac
  }

  -- Sets the label of current function
  fun enterFunction (fLabel, na, nl) {
    fun enter (env, n) {
      if n == 0
      then env
      else enter (env.allocate [1], n - 1)
      fi
    }
    
    enter (makeEnv ({}, 0, globals, false, emptyMap (compare), fLabel, nl), min (na, nRegArgs))
  }

  -- Gets the label of current function
  fun currentFunction () {
    fLabel
  }

  -- Gets the list of live registers past given symbolic stack depth
  fun liveRegisters (depth) {
    fun inner (d, acc, st) {
      case st of
        {}             -> acc
      | (r@R (_)) : tl -> inner (d+1, if d >= depth then r : acc else acc fi, tl)
      | _         : tl -> inner (d+1, acc, tl)
      esac
    }

    inner (0, {}, stack)
  }

   -- Gets a local static size for the current function
  fun staticSize () {
    nLocals + stackSlots
  }

  fun freeReg (R (i)) {
    stack.size <= i  
  }

  fun stackDepth () {
    stack.size
  }
  
  -- Returns list of registers in stack which may be corrupted by callee function
  -- x86_64: also adds padding reg if required
  fun regsToSave () {
    fun checkCell (cell) { 
      case cell of
        R (x) -> x > 0 && x < 8
      | _ -> false
      esac
    }
    
    let buf = if size (stack) >= 8 
      then {rcx, rsi, rdi, r8, r9, r10, r11}
      else filter (checkCell, stack) 
      fi in if size (buf) % 2 == 0 then buf else buf +++ {rax} fi
}

  [envString,
   alloc,
   push,
   pop,
   pop2,
   addGlobal,
   loc,
   getGlobals,
   getStackSize,
   peek,
   isBarrier,
   setBarrier,
   setStack,
   retrieveStack,
   enterFunction,
   currentFunction,
   liveRegisters,
   staticSize,
   freeReg,
   stackDepth,
   regsToSave]
}

-- Exported accessors
fun envString (env) {
  env [0] ()
}

fun allocate (env) {
  env [1] ()
}

fun push (env, x) {
  env [2] (x)
}

fun pop (env) {
  env [3] ()
}

fun pop2 (env) {
  env [4] ()
}

fun addGlobal (env, name) {
  env [5] (name)
}

fun loc (env, name) {
  env [6] (name)
}

fun getGlobals (env) {
  env [7] ()
}

fun getStackSize (env) {
  env [8] ()
}

fun peek (env) {
  env [9] ()
}

fun isBarrier (env) {
  env [10] ()
}

fun setBarrier (env) {
  env [11] ()
}

fun setStack (env, l) {
  env [12] (l)
}

fun retrieveStack (env, l) {
  env [13] (l)
}

fun enterFunction (env, fLabel, nA, nL) {
  env [14] (fLabel, nA, nL)
}

fun currentFunction (env) {
  env [15] ()
}

fun liveRegisters (env, depth) {
  env [16] (depth)
}

fun staticSize (env) {
  env [17] ()
}

fun freeReg (env, r) {
  env [18] (r)
}

fun stackDepth (env) {
  env [19] ()
}

fun regsToSave (env) {
  env [20] ()
}

-- Creates an initial environment
fun initEnv () {
  makeEnv ({}, 0, emptySet (compare), false, emptyMap (compare), "", 1)
}

-- Codegeneration helper functions
-- Generates code section
fun codeSection (text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
fun dataSection (text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates data definition
fun dataDef (name) {
  Meta (sprintf ("%s:\t.quad\t0\n", name))
}

-- Generates function prologue
fun prologue (fLabel) {
  singletonBuffer (Push  (rbp)) <+
  Mov   (rsp, rbp) <+
  Binop ("-", L (sprintf ("$%s_SIZE", fLabel)), rsp)  
}

fun epilogue (env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", env.currentFunction, env.staticSize * ((wordSize+1) / 2 * 2)));

  if compare (env.currentFunction, "main") == 0
  then [env, singletonBuffer (Mov (rbp, rsp)) <+ Pop (rbp) <+ Binop ("^", rax, rax) <+ Ret <+ metaDef]
  else case env.pop of
         [y, env] -> [env, singletonBuffer (Mov (rbp, rsp)) <+ Pop (rbp) <+ Mov (y, rax) <+ Ret <+ metaDef]
       esac
  fi
}

-- Checks if an operand resides on a stack
fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Checks if an operand resides in memory
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | I (_, _) -> true
  | _     -> false
  esac
}

-- Enframes a rdx-using code with save/restore
-- if RDX is occupied
fun withRDX (env, code) {
  if env.freeReg (rdx)
  then code  
  else singletonBuffer (Push (rdx)) <+> code <+ Pop (rdx)
  fi
}

fun preserveRdx (env, args, generator) {
  if freeReg (env, rdx)
  then generator (args)
  else 
    let code = generator (mapArray (
      fun (arg) { 
        case arg of
        -- @MergeCheck(R (2) == rdx)
          R (2) -> I (0, rsp)
        | _ -> arg esac 
      }, 
      args
    )) in 
      singletonBuffer (Push (rdx)) <+> code <+ Pop (rdx)
  fi
}

fun locsEqual (x, y) {
  case x of
    R (i)    -> case y of R (j) -> i == j | _ -> false esac
  | S (i)    -> case y of S (j) -> i == j | _ -> false esac
  | M (si)   -> case y of M (sj) -> compare (si, sj) == 0 | _ -> false esac
  | L (i)    -> case y of L (j) -> i == j | _ -> false esac
  | I (ni, ri) -> case y of I (nj, rj) -> ni == nj && locsEqual (ri, rj) | _ -> false esac
  | _ -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move (from, to) {
  if locsEqual (from, to)
  then emptyBuffer ()
  elif memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, rax)) <+ Mov (rax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

-- Gets push/pops for live registers (as buffers in
-- a proper order)
fun savecode (env, nA) {
  foldr (fun ([pushs, pops, size], r) {
           [singletonBuffer (Push (r)) <+> pushs, pops <+ Pop (r), size + 1]
         },
	 [emptyBuffer (), emptyBuffer (), 0],
	 env.liveRegisters (nA)
  )
}

fun argLoc (idx) {
  if idx < nRegArgs then R (idx)
  else OnStack fi
} 

fun call (env, fLabel, nA) {
  generalCall (env, fLabel, nA, true)
}

fun voidCall (env, fLabel, nA) {
  generalCall (env, fLabel, nA, false)
}

fun generalCall (env, fLabel, nA, hasReturnValue) {
  fun storeArgs (env, nA, acc, nStackArgs) {
    case nA of 
      0 -> [acc, nStackArgs, env]
    | _ ->
      let [x, env] = pop (env) in 
      let [moveCode, stackSlots] = case argLoc (nA - 1) of
        OnStack -> [singletonBuffer (Push (x)), 1]
      | loc -> [move (x, loc), 0]
      esac in
        storeArgs (env, nA - 1, acc <+> moveCode, nStackArgs + stackSlots)
    esac
  }
  let [pushes, pops, saveSize] = savecode (env, nA) in
  let [store, nStackArgs, env] = storeArgs (env, nA, emptyBuffer (), 0) in
  let [pushPadding, popPadding] = if (saveSize + nStackArgs) % 2 == 0 
    then [emptyBuffer (), emptyBuffer ()]
    else [singletonBuffer (Push (rax)), singletonBuffer (Pop (rax))]
  fi in
  let [loadRes, env] = if hasReturnValue 
    then let [res, env] = allocate (env) in [singletonBuffer (Mov (rax, res)), env] 
    else [emptyBuffer (), env]
  fi in
  let releaseCode = if nStackArgs > 0 
    then singletonBuffer (Binop ("+", L (nStackArgs * wordSize), rsp)) 
    else emptyBuffer ()
  fi in
    [pushes <+> pushPadding <+> store <+ Call (fLabel) <+> releaseCode <+> loadRes <+> popPadding <+> pops, env]
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
fun suffix (op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  esac
}

fun setStackBarrier (env, l) {
  let env = setStack (env, l) in
    setBarrier (env)
}

-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (env, code) {
  foldl (
    fun ([env, scode], i) {
      var code = scode <+ Meta ("# " ++ showSMInsn (i) ++ "\n");

      -- printf ("compiling %s\n", showSMInsn (i));
      
      case i of      
        READ ->
          let [callCode, env] = call (env, "Lread", 0) in
            [env, code <+> callCode]
      | WRITE ->
          let [callCode, env] = voidCall (env, "Lwrite", 1) in
            [env, code <+> callCode]
      | LD (x) ->
          let [s, env] = allocate (env) in [env, code <+> move (loc (env, x), s)]
      | ST (x) ->
          let [s, env] = pop (env) in [env, code <+> move (s, loc (env, x))]
      | CONST (x) ->
          let [s, env] = allocate (env) in [env, code <+> move (L (x), s)]
      | LABEL (l) -> let env = if isBarrier (env) then retrieveStack (env, l) else env fi in [env, code <+ Label (l)]
      | JMP (l) -> [setStackBarrier (env, l), code <+ Jmp (l)]
      | CJMP (cc, l) -> let [s, env] = pop (env) in [setStackBarrier (env, l), code <+ Binop ("cmp", L (0), s) <+ CJmp (cc, l)]
      | BINOP (op) ->
          let initEnv = env in
          let [y, x, env] = pop2 (env) in
            if memOpnd (x) && memOpnd (y) && op != "/" && op != "%" && op != "*" then 
              code := code <+ Mov (y, rax);
              y := rax
            fi;
            
            code := code <+> case op of
              "+"  -> singletonBuffer (Binop ("+", y, x))
            | "-"  -> singletonBuffer (Binop ("-", y, x))
            | "*"  -> 
              if memOpnd (x) then 
                singletonBuffer (Mov (x, rax)) <+ Binop ("*", y, rax) <+ Mov (rax, x)
              else 
                singletonBuffer (Binop ("*", y, x)) 
              fi
            | "&&" -> preserveRdx (
              initEnv,
              [x, y],
              fun ([x, y]) { 
                singletonBuffer (Binop ("^", rax, rax)) -- rax = 0
                  <+ Binop ("^", rdx, rdx)              -- rdx = 0
                  <+ Binop ("cmp", L (0), x)            -- flags = compare(0, x)
                  <+ Set (suffix ("!="), al)            -- rax[7:0] = (0 != x)
                  <+ Binop ("cmp", L (0), y)            -- flags = compare(0, y)
                  <+ Set (suffix ("!="), ah)            -- rax[15:8] = (0 != y)
                  <+ Binop ("cmp", L (257), rax)        -- flags = compare(0x0101, rax)
                  <+ Set (suffix ("=="), dl)            -- rdx[7:0] = (0x0101 == rax)
                  <+ Mov (rdx, x)                       -- x = rdx
              }
            )
            | "!!" -> preserveRdx (
              initEnv,
              [x, y],
              fun ([x, y]) { 
                singletonBuffer (Binop ("^", rax, rax)) -- rax = 0
                  <+ Binop ("^", rdx, rdx)              -- rdx = 0
                  <+ Binop ("cmp", L (0), x)            -- flags = compare(0, x)
                  <+ Set (suffix ("!="), al)            -- rax[7:0] = (0 != x)
                  <+ Binop ("cmp", L (0), y)            -- flags = compare(0, y)
                  <+ Set (suffix ("!="), ah)            -- rax[15:8] = (0 != y)
                  <+ Binop ("cmp", L (0), rax)          -- flags = compare(0, rax)
                  <+ Set (suffix ("!="), dl)            -- rdx[7:0] = (0 != rax)
                  <+ Mov (rdx, x)                       -- x = rdx
              }
            )
            | "/"  -> preserveRdx (
              initEnv,
              [x, y],
              fun ([x, y]) { singletonBuffer (Mov (x, rax)) <+ Cltd <+ IDiv (y) <+ Mov (rax, x) }
            )
            | "%"  -> preserveRdx (
              initEnv,
              [x, y], 
              fun ([x, y]) { singletonBuffer (Mov (x, rax)) <+ Cltd <+ IDiv (y) <+ Mov (rdx, x) }
            )
            | _    ->
              singletonBuffer (Binop ("^", rax, rax))
                <+ Binop ("cmp", y, x)
                <+ Set (suffix (op), al)
                <+ Mov (rax, x)
            esac;
            
            [push (env, x), code]
      | LDA (x) -> let [s, env] = allocate (env) in [env, code <+ Lea (loc (env, x), s)]
      | STI -> 
        let [v, ref, env] = pop2 (env) in
        let [vNew, env] = allocate (env) in 
          if memOpnd (ref) then
            [env, code <+> preserveRdx (
              initEnv, 
              [ref, v, vNew], 
              fun ([ref, v, vNew]) { move (ref, rdx) <+> move (v, I (0, rdx)) <+> move (v, vNew) }
            )]
          else 
           [env, code <+> move (v, I (0, ref)) <+> move (v, vNew)]
          fi
      | DROP -> let [_, env] = pop (env) in [env, code]
      | DUP -> 
          let [x, env] = peek (env) in 
          let [s, env] = allocate (env) in
            [env, code <+> move (s, x)]
      | CALL (f, n) -> 
          let [callCode, env] = call (env, f, n) in
            [env, code <+> callCode]
      | BEGIN (f, a, l) ->
          let env = enterFunction (env, f, a, l) in 
            [env, code <+> prologue (f)]
      | END ->
          let [env, epilogue] = epilogue (env) in
            [env, code <+> epilogue]
      | GLOBAL (x) -> [addGlobal (env, x), code]
      | _ -> failure ("codegeneration for instruction %s is not yet implemented\n", string (i))
      esac
    }, [env, emptyBuffer ()], code)
}

-- A top-level codegeneration function. Takes a driver's environment and a stack machine program,
-- compiles the program into machine code, and compiles the machine code into an executable
public fun compileX86 (args, code) {
  case compile (initEnv (), code) of
    [env, code] ->
       var asmFile = getBaseName (args) ++ ".s",
           runtime = case getEnv ("LAMA_RUNTIME") of
                       #val  -> "../runtime64/"
                     | path  -> path
                     esac ++ "/runtime.o";
       
       fwrite (asmFile,
               stringcat (map (insnString, 
                    getBuffer $
                      singletonBuffer (Meta ("\t.global\tmain\n")) <+>
                      dataSection (listBuffer $ map (dataDef, getGlobals (env))) <+>
		      codeSection (code)
                    )));
                    
       system (stringcat ({"gcc -g -o ", getBaseName (args), " ", runtime, " ", asmFile}))
  esac
}
