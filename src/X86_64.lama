-- Модуль генерации x86-64 ассемблера
-- Преобразует программы стековой машины в x86-64 код
import SM;
import Collection;
import List;
import Buffer;
import Fun;
import Manifest;

-- Определения регистров x86-64
var x86Registers = ["%rbx", "%rcx", "%rsi", "%rdi", "%r8", "%r9", 
                   "%r10", "%r11", "%r12", "%r13", "%r14", "%r15",
                   "%rax", "%rdx", "%rbp", "%rsp"];

var maxUsableRegs = x86Registers.length - 5;
var memoryWordSize = 8;

-- Сокращения для регистров
var regEBX = R(0), regECX = R(1), regESI = R(2), regEDI = R(3),
    regR8 = R(4), regR9 = R(5), regR10 = R(6), regR11 = R(7),
    regR12 = R(8), regR13 = R(9), regR14 = R(10), regR15 = R(11),
    regEAX = R(12), regEDX = R(13), regEBP = R(14), regESP = R(15);

-- Преобразование инструкций в строки ассемблера
fun instructionToString (instruction) {
  
  fun getOperatorName (op) {
    case op of
      "+" -> "addq" | "-" -> "subq" | "*" -> "imulq"
    | "&&" -> "andq" | "!!" -> "orq" | "^" -> "xorq" | "cmp" -> "cmpq"
    esac
  }

  fun getOperandName (operand) {
    case operand of
      R(index) -> x86Registers[index]
    | S(stackPos) -> sprintf("-%d(%%rbp)", (stackPos + 1) * memoryWordSize)
    | M(varName) -> sprintf("%s(%%rip)", varName)
    | L(literal) -> sprintf("$%d", literal)
    esac
  }
  
  case instruction of
    Cltd -> "\tcqo\n"
  | Set(condition, target) -> sprintf("\tset%s\t%s\n", condition, target)
  | Sal(operand) -> sprintf("\tsalq\t%s\n", operand)
  | IDiv(divisor) -> sprintf("\tidivq\t%s\n", getOperandName(divisor))
  | Binop(operation, src, dst) -> sprintf("\t%s\t%s,\t%s\n", getOperatorName(operation), getOperandName(src), getOperandName(dst))
  | Mov(source, destination) -> sprintf("\tmovq\t%s,\t%s\n", getOperandName(source), getOperandName(destination))
  | Push(operand) -> sprintf("\tpushq\t%s\n", getOperandName(operand))
  | Pop(operand) -> sprintf("\tpopq\t%s\n", getOperandName(operand))
  | Ret -> "\tret\n"
  | Call(funcName) -> sprintf("\tcall\t%s\n", funcName)
  | Meta(info) -> info
  | Label(l) -> sprintf("%s:\n", l)
  | Jmp(l) -> sprintf("\tjmp\t%s\n", l)
  | CJmp(cond, l) -> sprintf("\tj%s\t%s\n", cond, l)
  esac
}

-- Управление окружением компиляции
fun createCompilationEnvironment (symbolStack, maxStackDepth, globalVars) {
  
  fun makeGlobalVarName (name) {
    "global_" ++ name
  }

  fun getEnvironmentInfo () {
    sprintf("Стек: %s\nМакс глубина: %d\nГлобальные: %s\n", 
            symbolStack.string, maxStackDepth, elements(globalVars).string)
  }
  
  fun reserveStackPosition () {
    case case symbolStack of
           0 -> [regEBX, 0]
         | S(pos): _ -> [S(pos + 1), pos + 2]
         | R(regNum): _ -> if regNum < maxUsableRegs then [R(regNum + 1), maxStackDepth] else [S(0), 1] fi
         | _ -> [S(0), 1]
         esac of
      [location, newDepth] -> [location, createCompilationEnvironment(location : symbolStack, 
                                                                     if newDepth > maxStackDepth then newDepth else maxStackDepth fi, 
                                                                     globalVars)]
    esac
  }

  fun addToStack (item) {
    createCompilationEnvironment(item : symbolStack, maxStackDepth, globalVars)
  }

  fun removeFromStack () {
    case symbolStack of
      item: rest -> [item, createCompilationEnvironment(rest, maxStackDepth, globalVars)]
    esac
  }

  fun removeTwoFromStack () {
    case symbolStack of
      first: second: rest -> [first, second, createCompilationEnvironment(rest, maxStackDepth, globalVars)]
    esac
  }

  fun registerGlobalVar (varName) {
    createCompilationEnvironment(symbolStack, maxStackDepth, addSet(globalVars, makeGlobalVarName(varName)))
  }

  fun getGlobalVarLocation (varName) {
    M(makeGlobalVarName(varName))
  }
  
  fun getAllGlobalVars () {
    globalVars.elements
  }

  fun getMaxStackDepth () {
    maxStackDepth
  }

  [getEnvironmentInfo, reserveStackPosition, addToStack, removeFromStack, removeTwoFromStack, 
   registerGlobalVar, getGlobalVarLocation, getAllGlobalVars, getMaxStackDepth]
}

-- Интерфейсы доступа к окружению
fun getEnvInfo (env) { env[0]() }
fun allocateSpace (env) { env[1]() }
fun pushToEnv (env, item) { env[2](item) }
fun popFromEnv (env) { env[3]() }
fun popTwoFromEnv (env) { env[4]() }
fun addGlobalVar (env, name) { env[5](name) }
fun getGlobalLocation (env, name) { env[6](name) }
fun getGlobalVarList (env) { env[7]() }
fun getStackDepth (env) { env[8]() }

-- Создание начального окружения
fun initializeEnvironment () {
  createCompilationEnvironment(0, 0, emptySet(compare))
}

-- Генераторы секций кода
fun generateCodeSection (instructions) {
  singletonBuffer(Meta("\t.text\n")) <+ instructions
}

fun generateDataSection (data) {
  singletonBuffer(Meta("\t.data\n")) <+ data
}

fun generateVariableDefinition (varName) {
  Meta(sprintf("%s:\t.quad\t0\n", varName))
}

fun generateFunctionPrologue (stackSize) {
  singletonBuffer(Push(regEBP)) <+ Mov(regESP, regEBP) <+ Binop("-", L(memoryWordSize * stackSize), regESP)
}

fun generateFunctionEpilogue () {
  singletonBuffer(Mov(regEBP, regESP)) <+ Pop(regEBP) <+ Binop("^", regEAX, regEAX) <+ Ret
}

-- Проверки типов операндов
fun isStackOperand (operand) {
  case operand of S(_) -> true | _ -> false esac
}

fun isMemoryOperand (operand) {
  case operand of S(_) -> true | M(_) -> true | _ -> false esac
}

-- Генерация перемещений с учетом ограничений x86
fun generateSafeMove (source, target) {
  if isMemoryOperand(source) && isMemoryOperand(target) 
  then singletonBuffer(Mov(source, regEAX)) <+ Mov(regEAX, target)
  else singletonBuffer(Mov(source, target))
  fi
}

-- Получение суффиксов для условных инструкций
fun getConditionSuffix (operator) {
  case operator of
    "<" -> "l" | "<=" -> "le" | "==" -> "e" 
  | "!=" -> "ne" | ">=" -> "ge" | ">" -> "g"
  esac
}

-- Обработчик бинарных операций
fun handleBinaryOperation (operator, environment, codeBuffer) {
  case environment.popTwoFromEnv of
    [rightOperand, leftOperand, newEnv] ->
      case newEnv.allocateSpace of
        [resultLocation, finalEnv] ->
          case operator of
            -- Арифметические операции
            "+" -> [finalEnv, codeBuffer <+ Mov(leftOperand, resultLocation) <+ Binop("+", rightOperand, resultLocation)]
          | "-" -> [finalEnv, codeBuffer <+ Mov(leftOperand, resultLocation) <+ Binop("-", rightOperand, resultLocation)]  
          | "*" -> [finalEnv, codeBuffer <+ Mov(leftOperand, resultLocation) <+ Binop("*", rightOperand, resultLocation)]
            -- Деление и остаток
          | "/" -> [finalEnv, codeBuffer <+ Mov(leftOperand, regEAX) <+ Cltd <+ IDiv(rightOperand) <+ Mov(regEAX, resultLocation)]
          | "%" -> [finalEnv, codeBuffer <+ Mov(leftOperand, regEAX) <+ Cltd <+ IDiv(rightOperand) <+ Mov(regEDX, resultLocation)]
            -- Операции сравнения  
          | "<" -> [finalEnv, generateComparisonCode(codeBuffer, leftOperand, rightOperand, resultLocation, "<")]
          | "<=" -> [finalEnv, generateComparisonCode(codeBuffer, leftOperand, rightOperand, resultLocation, "<=")]
          | ">" -> [finalEnv, generateComparisonCode(codeBuffer, leftOperand, rightOperand, resultLocation, ">")]
          | ">=" -> [finalEnv, generateComparisonCode(codeBuffer, leftOperand, rightOperand, resultLocation, ">=")]
          | "==" -> [finalEnv, generateComparisonCode(codeBuffer, leftOperand, rightOperand, resultLocation, "==")]
          | "!=" -> [finalEnv, generateComparisonCode(codeBuffer, leftOperand, rightOperand, resultLocation, "!=")]
            -- Логические операции
          | "&&" -> [finalEnv, generateLogicalCode(codeBuffer, leftOperand, rightOperand, resultLocation, "&&")]
          | "!!" -> [finalEnv, generateLogicalCode(codeBuffer, leftOperand, rightOperand, resultLocation, "!!")]
            esac
      esac
  esac
}

-- Вспомогательные функции для сложных операций
fun generateComparisonCode (code, left, right, result, op) {
  code <+ Mov(left, regEAX) <+ Binop("cmp", right, regEAX) <+ 
  Set(getConditionSuffix(op), "%al") <+ Binop("&&", L(1), regEAX) <+ Mov(regEAX, result)
}

fun generateLogicalCode (code, left, right, result, op) {
  code <+ Binop("cmp", L(0), right) <+ Set(getConditionSuffix("!="), "%al") <+ Mov(regEAX, right) <+ 
  Binop("cmp", L(0), left) <+ Set(getConditionSuffix("!="), "%al") <+ Binop(op, right, regEAX) <+ 
  Binop("&&", L(1), regEAX) <+ Mov(regEAX, result)
}

fun compileInstructions (environment, instructionList) {
  foldl(fun ([currentEnv, generatedCode], instruction) {
    var debugCode = generatedCode <+ Meta("# " ++ showSMInsn(instruction) ++ "\n");
    
    case instruction of
      -- Ввод-вывод  
      READ -> case currentEnv.allocateSpace of
                [location, updatedEnv] -> [updatedEnv, debugCode <+ Call("Lread") <+ Mov(regEAX, location)]
              esac
    | WRITE -> case currentEnv.popFromEnv of
                 [source, updatedEnv] -> [updatedEnv, debugCode <+ Mov(source, regEDI) <+ Call("Lwrite")]
               esac
      -- Константы
    | CONST(value) -> case currentEnv.allocateSpace of
                        [location, updatedEnv] -> [updatedEnv, debugCode <+ Mov(L(value), location)]
                      esac
      -- Переменные
    | LD(variable) -> case currentEnv.addGlobalVar(variable).allocateSpace of
                        [location, updatedEnv] -> [updatedEnv, debugCode <+> generateSafeMove(currentEnv.getGlobalLocation(variable), location)]
                      esac
    | ST(variable) -> case currentEnv.addGlobalVar(variable).popFromEnv of
                        [source, updatedEnv] -> [updatedEnv, debugCode <+> generateSafeMove(source, currentEnv.getGlobalLocation(variable))]
                      esac
      -- Бинарные операции
    | BINOP(op) -> handleBinaryOperation(op, currentEnv, debugCode)
    | LABEL(l) -> [currentEnv, debugCode <+ Label(l)]
    | JMP(l) -> [currentEnv, debugCode <+ Jmp(l)]
    | CJMP(condition, l) -> 
        case currentEnv.popFromEnv of
          [stack_top_operand, env_after_pop] ->
            var code_with_cmp = debugCode <+ Mov(stack_top_operand, regEAX) <+ Binop("cmp", L(0), regEAX);
            case condition of
              "z"  -> [env_after_pop, code_with_cmp <+ CJmp("e", l)]
            | "nz" -> [env_after_pop, code_with_cmp <+ CJmp("ne", l)]
            esac
        esac
    | BF(l) ->
        case currentEnv.popFromEnv of
          [condSrc, uEnv] ->
            [uEnv, debugCode <+> generateSafeMove(condSrc, regEAX) <+ Binop("cmp", L(0), regEAX) <+ CJmp("e", l)]
        esac
    | _ -> failure("Инструкция %s не реализована\n", instruction.string)
    esac
  }, [environment, emptyBuffer()], instructionList)
}

-- Основная функция компиляции (обновлена для T03)
public fun compileX86 (args, stackMachineCode) {
  case compileInstructions(initializeEnvironment(), stackMachineCode) of
    [finalEnv, compiledCode] -> 
      var asmFile = getBaseName(args) ++ ".s",
          runtime = case getEnv("LAMA_RUNTIME") of
                      #val -> "../runtime64/"
                    | path -> path
                    esac ++ "/runtime.o";
      
      var globalMainList = getBuffer(singletonBuffer(Meta("\t.global\tmain\n")));
      
      var globalVarsDefinitionsList = map(generateVariableDefinition, finalEnv.getGlobalVarList);
      var dataSectionList = {Meta("\t.data\n")} +++ globalVarsDefinitionsList;
      
      var mainLabelList = getBuffer(singletonBuffer(Meta("main:\n")));
      var prologueList = getBuffer(generateFunctionPrologue(finalEnv.getStackDepth));
      var compiledCodeList = getBuffer(compiledCode); 
      var epilogueList = getBuffer(generateFunctionEpilogue());

      var codeSectionList = {Meta("\t.text\n")} +++ mainLabelList +++ prologueList +++ compiledCodeList +++ epilogueList;

      fwrite(asmFile, map(instructionToString, globalMainList +++ dataSectionList +++ codeSectionList).stringcat);
      system({"gcc -g -o ", getBaseName(args), " ", runtime, " ", asmFile}.stringcat)
  esac
}