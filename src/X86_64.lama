-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import SM;
import Collection;
import List;
import Buffer;
import Fun;
import Manifest;

fun min (x, y) {
  if x > y then y else x fi
}

fun max (x, y) {
  if x > y then x else y fi
}

-- Assembler language interface
-- The registers:
var regs = ["%rdi", "%rsi", "%rdx", "%rcx",
            "%r8" , "%r9" , "%r10", "%r11",
	    "%r12", "%r13", "%r14", "%r15",
	    "%rbx", "%rax", "%rbp", "%rsp"];

-- We can not freely operate with all register; only with 13 by now;
-- we also notify that the 6 first register are used to
-- pass arguments to a function
var nRegs    = regs.length - 4,
    nRegArgs = 6;

-- For convenience we define the following synonyms for the registers: 
var rdi = R (0),
    rsi = R (1),
    rdx = R (2),
    rcx = R (3),
    r8  = R (4),
    r9  = R (5),
    r10 = R (6),
    r11 = R (7),
    r12 = R (8),
    r13 = R (9),
    r14 = R (10),
    r15 = R (11),
    rbx = R (12),
    rax = R (13),
    rbp = R (14),
    rsp = R (15);

-- We need to know the word size to calculate offsets correctly
var wordSize = 8;
-- We need to distinguish the following operand types: 
--    R (int)        -- hard register                    
--    S (int)        -- a position on the hardware stack 
--    M (string)     -- a named memory location          
--    L (int/string) -- an immediate operand             
--    I (int, opnd)  -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)

--
--   Dec   (opnd)               -- arithmetic correction: decrement  
--   Or1   (opnd)               -- arithmetic correction: or 0x0001                     
--   Sal1  (opnd)               -- arithmetic correction: shl 1           
--   Sar1  (opnd)               -- arithmetic correction: shr 1

-- Machine instruction printer
fun insnString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addq"
    | "-"   -> "subq"
    | "*"   -> "imulq"
    | "&&"  -> "andq"
    | "!!"  -> "orq" 
    | "^"   -> "xorq"
    | "cmp" -> "cmpq"
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i)      -> regs [i]
    | S (i)      -> if i >= 0
                    then sprintf ("-%d(%%rbp)", (i+1) * wordSize)
                    else sprintf ("%d(%%rbp)", wordSize * 2 + (-1-i) * wordSize)
                    fi

    | M (x)      -> sprintf ("%s(%rip)", x)
    | L (i@#val) -> sprintf ("$%d", i)
    | L (i@#str) -> sprintf ("%s", i)
    | I (0, x)   -> sprintf ("(%s)", opndString (x))
    | I (n, x)   -> sprintf ("%d(%s)", n, opndString (x))
    esac
  }
  
  case insn of
    Cltd               -> "\tcqo\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | Sal   (s)          -> sprintf ("\tsalq\t%s\n", s)
  | IDiv  (s1)         -> sprintf ("\tidivq\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovq\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Lea   (s1, s2)     -> sprintf ("\tleaq\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushq\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopq\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", c, l)
  | Meta  (m)          -> m
  | Dec   (s)          -> sprintf ("\tdecq\t%s\n", opndString (s))
  | Or1   (s)          -> sprintf ("\torq\t$0x0001,\t%s\n", opndString (s))
  | Sal1  (s)          -> sprintf ("\tsalq\t%s\n", opndString (s))
  | Sar1  (s)          -> sprintf ("\tsarq\t%s\n", opndString (s))
  | x -> sprintf("%s\n", x.string)  
  esac
}

-- Gets a name of a symbol designating an S-expression's tag
fun tagSym (tag) {
  sprintf ("%s$tag", tag)
}

-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names
--    a barrier condition (set up right after an unconditional jump is interpreter)
--    a stack map which maps labels to symbolic stacks

fun makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals) {
  -- Returns an internal name for a global variable
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", string(stack), stackSlots, string(elements (globals)))
  }
  
  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun alloc () {
    case 
      case stack of
        {}        -> [rdi, 0]
      | S (n) : _ -> [S (n+1), n+2]
      | R (n) : _ -> if n < nRegs then [R (n+1), stackSlots] else [S (nLocals), nLocals + 1] fi
      | _         -> [S (nLocals), nLocals + 1]
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  fun pop (stri) {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
      | _ -> failure("pop: %s\n", stri) --//
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an undated environment
  fun pop2 () {
    case stack of
      x : y : stack -> [x, y, makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Peeks the top of the symbolic stack
  fun peek () {
    fst(stack)
  }
  
  -- Adds a global variable; returns an updated environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)), strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  -- References an allocation
  fun loc (alloc) {
    case alloc of
      Glb (x) -> M (globalName (x))
    | Arg (i) -> if i < nRegArgs then R (i) else S (-1-(i - nRegArgs)) fi
    | Loc (i) -> S (i)
    esac
  }
  
  -- Gets a list of global variables from the environment
  fun getGlobals () {
    elements(globals)
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize () {
    stackSlots
  }

  -- Gets barrier condition
  fun isBarrier () {
    barrier
  }

  -- Sets barrier condition
  fun setBarrier () {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, true, stackMap, fLabel, nLocals)
  }

  -- Associates the current symbolic state with a label
  fun setStack (l) {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, false, addMap (stackMap, l, stack), fLabel, nLocals)
  }

  -- Retrieves a stack for a label
  fun retrieveStack (l) {
    case findMap (stackMap, l) of
      None         -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    | Some (stack) -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    esac
  }

  -- Drops a barrier
  fun dropBarrier () {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
  }
  
  -- Checks if a stack is set for a label
  fun hasStack (l) {
    compare (findMap (stackMap, l), None) != 0
  }

  -- Sets the label of current function
  fun enterFunction (fLabel, na, nl) {
    fun enter (env, n) {
      if n == 0
      then env
      else enter (allocate(env) [1], n - 1)
      fi
    }
    
    enter (makeEnv ({}, 0, globals, strings, stringIndex, false, emptyMap (compare), fLabel, nl), min (na, nRegArgs))
  }

  -- Gets the label of current function
  fun currentFunction () {
    fLabel
  }

  -- Gets the list of live registers past given symbolic stack depth
  fun liveRegisters (depth) {
    fun inner (d, acc, st) {
      case st of
        {}             -> acc
      | (r@R (_)) : tl -> inner (d+1, if d >= depth then r : acc else acc fi, tl)
      | _         : tl -> inner (d+1, acc, tl)
      esac
    }

    inner (0, {}, stack)
  }

  -- Registers a string literal and assigns it a name
  fun addString (s) {
    var escaped = makeString ((s.length + 1) * 2), i = 0, j = 0, name = sprintf ("string_%d", stringIndex);

    for skip, i < s.length, i := i+1 do
      case s[i] of
        '"'  -> escaped [j] :='"'; escaped [j+1] := '"'; j := j+2
      | '\n' -> escaped [j] :='\'; escaped [j+1] := 'n'; j := j+2
      | '\t' -> escaped [j] :='\'; escaped [j+1] := 't'; j := j+2
      | c    -> escaped [j] := c; j := j+1
      esac
    od;
    
    [makeEnv (stack, stackSlots, globals, addSet (strings, [name, substring (escaped, 0, j)]), stringIndex+1, false, stackMap, fLabel, nLocals), name]
  }

  -- Gets a list of all string literals and their names
  fun getStrings () {
    elements (strings)
  }

   -- Gets a local static size for the current function
  fun staticSize () {
    nLocals + stackSlots
  }

  fun freeReg (R (i)) {
    size(stack) <= i  
  }

  fun stackDepth () {
    size(stack)
  }

  fun addTag (tag) {
    let sym = tagSym (tag) in
    [sym, makeEnv (stack, stackSlots, globals, addSet (strings, [sym, tag]), stringIndex, barrier, stackMap, fLabel, nLocals)]
  }
  
  [envString,
   alloc,
   push,
   pop,
   pop2,
   addGlobal,
   loc,
   getGlobals,
   getStackSize,
   peek,
   isBarrier,
   setBarrier,
   setStack,
   retrieveStack,
   enterFunction,
   currentFunction,
   liveRegisters,
   staticSize,
   freeReg,
   stackDepth,
   addString,
   getStrings,
   addTag,
   hasStack,
   dropBarrier]
}
-- Exported accessors
fun envString (env) {
   env[0]()
}
fun allocate (env) {
   env[1]()
}
fun push (env, x) {
   env[2](x)
}
fun pop (env, stri) {
   env[3](stri)
}
fun pop2 (env) {
   env[4]()
}
fun addGlobal (env, name) {
   env[5](name)
}
fun loc (env, name) {
   env[6](name)
}
fun getGlobals (env) {
   env[7]()
}
fun getStackSize (env) {
   env[8]()
}

fun peek (env) {
  env [9] ()
}

fun isBarrier (env) {
  env [10] ()
}

fun setBarrier (env) {
  env [11] ()
}

fun setStack (env, l) {
  env [12] (l)
}

fun retrieveStack (env, l) {
  env [13] (l)
}

fun enterFunction (env, fLabel, nA, nL) {
  env [14] (fLabel, nA, nL)
}

fun currentFunction (env) {
  env [15] ()
}

fun liveRegisters (env, depth) {
  env [16] (depth)
}

fun staticSize (env) {
  env [17] ()
}

fun freeReg (env, r) {
  env [18] (r)
}

fun stackDepth (env) {
  env [19] ()
}

fun addString (env, s) {
  env [20] (s)
}

fun getStrings (env) {
  env [21] ()
}

fun addTag (env, tag) {
  env [22] (tag)
}

fun hasStack (env, l) {
  env [23] (l)
}

fun dropBarrier (env) {
  env [24] ()
}

-- Creates an initial environment
fun initEnv () {
  makeEnv ({}, 0, emptySet (compare), emptySet (compare), 0, false, emptyMap (compare), "", 1)
}

-- Codegeneration helper functions
-- Generates code section
fun codeSection (text) {
   singletonBuffer(Meta("\t.text\n")) <+> text
}
-- Generates data section
fun dataSection (text) {
   singletonBuffer(Meta("\t.data\n")) <+> text
}

-- Generates integer definition
fun intDef (name) {
  Meta (sprintf ("%s:\t.quad\t0\n", name))
}

-- Generates string definition
fun stringDef ([name, vl]) {
  Meta (sprintf ("%s:\t.string\t""%s""\n", name, vl))
}

-- Generates function prologue
fun prologue (fLabel) {
  singletonBuffer (Push  (rbp)) <+
  Mov   (rsp, rbp) <+
  Binop ("-", L (sprintf ("$%s_SIZE", fLabel)), rsp)  
}

fun epilogue (env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", currentFunction(env), staticSize(env) * wordSize));

  if compare (currentFunction(env), "main") == 0
  then [env, singletonBuffer (Mov (rbp, rsp)) <+ Pop (rbp) <+ Binop ("^", rax, rax) <+ Ret <+ metaDef]
  else case pop(env, "epi") of
         [y, env] -> [env, singletonBuffer (Mov (rbp, rsp)) <+ Pop (rbp) <+ Mov (y, rax) <+ Ret <+ metaDef]
       esac
  fi
}
-- Checks if an operand resides on a stack
fun stackOpnd (opnd) {
   case opnd of
     S(_) -> true
   | _    -> false
   esac
}
-- Checks if an operand resides in memory
fun memOpnd (opnd) {
   case opnd of
     S(_) -> true
   | M(_) -> true
   | _    -> false
   esac
}

-- Enframes a rdx-using code with save/restore
-- if RDX is occupied
fun withRDX (env, code) {
  if freeReg (env, rdx)
  then code  
  else singletonBuffer (Push (rdx)) <+> code <+ Pop (rdx)
  fi
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, rax)) <+ Mov (rax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

-- Generates a lea between locations, using
-- intermediate register if needed
fun lea (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Lea (from, rax)) <+ Mov (rax, to)
  else singletonBuffer (Lea (from, to))
  fi
}

-- Gets push/pops for live registers
fun savecode (env, nA) {
  foldr (fun ([pushs, pops], r) {
           [singletonBuffer (Push (r)) <+> pushs, pops <+ Pop (r)]
         },
	 [emptyBuffer (), emptyBuffer ()],
	 liveRegisters (env, nA)
  )
}

-- Generates a static call
-- Don't forget to handle buitins (Barray/Bsexp), and
-- to clear rax before calling to variable arg funcations
fun call (env, fLabel, nA) {
  var codes = savecode(env, nA);
  var code = codes[0];
  if stackDepth(env) == nA
    then
      var clearCode;
      for var i = nA;, i > 0, i := i - 1 do
        case pop(env, "call") of
          [x, newEnv] ->  env := newEnv;
                          code := if i > nRegArgs
                                    then code <+ Mov(x, rax) <+ Push(rax)
                                    else code
                                  fi
        esac
      od;
      case fLabel of
        "Barray" -> clearCode := code <+ Binop("^", rax, rax)
        | "Bsexp" -> clearCode := code <+ Binop("^", rax, rax)
        | _ -> clearCode := code
      esac;
      if nA > nRegArgs
        then let [s, env] = allocate(env) in [env, ((clearCode <+ Call(fLabel) <+ Binop("-", L(wordSize * (nA - nRegArgs)), rsp))
                <+> codes[1]) <+ Mov(rax, s)]
        else let [s, env] = allocate(env) in [env, ((clearCode <+ Call(fLabel)) <+> codes[1]) <+ Mov(rax, s)]
      fi
    else
      var clearCode;
      var revCode = emptyBuffer();
      for var i = nA;, i > 0, i := i - 1 do
        case pop(env, "else call") of
          [x, newEnv] ->  env := newEnv;
                          if i > nRegArgs
                            then code := code <+ Mov(x, rax) <+ Push(rax)
                            else revCode := singletonBuffer(Mov(x, R(i - 1))) <+> revCode
                          fi
        esac
      od;
      code := code <+> revCode;
      case fLabel of
        "Barray" -> clearCode := code <+ Binop("^", rax, rax)
        | "Bsexp" -> clearCode := code <+ Binop("^", rax, rax)
        | _ -> clearCode := code
      esac;
      if nA > nRegArgs
        then let [s, env] = allocate(env) in [env, ((clearCode <+ Call(fLabel) <+ Binop("-", L(wordSize * (nA - nRegArgs)), rsp))
                <+> codes[1]) <+ Mov(rax, s)]
        else let [s, env] = allocate(env) in [env, ((clearCode <+ Call(fLabel)) <+> codes[1]) <+ Mov(rax, s)]
      fi
  fi
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
fun suffix (op) {
   case op of
     "<"  -> "l"
   | "<=" -> "le"
   | "==" -> "e"
   | "!=" -> "ne"
   | ">=" -> "ge"
   | ">"  -> "g"
   esac
}

-- Boxes an immediate value
fun makeBox (n) {
  n * 2 + 1
}

-- Generates a fixednum representation
-- conversion
fun toFixedNum (r) {
  singletonBuffer (Sal1 (r)) <+ Or1 (r)
}

fun leaHelper(env, from, to) {
  if memOpnd(to)
    then (singletonBuffer(Lea(from, rax)) <+ Mov(rax, to))
  else singletonBuffer(Lea(from, to))
  fi
}

fun moveToAddressChecker(cv, r) {
  if memOpnd(r)
    then singletonBuffer(Mov(r, rdx)) <+ Mov(cv, I(0, rdx))
  else
    singletonBuffer(Mov(cv, I(0, r)))
  fi
}

fun moveToAddressHelper(v, r) {
  if memOpnd(v)
    then singletonBuffer(Mov(v, rax)) <+> moveToAddressChecker(rax, r)
  else
    moveToAddressChecker(v, r)
  fi
}

-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (args, env, code) {
  foldl (
    fun ([env, scode], i) {
      var code = scode <+ Meta ("# " ++ showSMInsn (i) ++ "\n");

      --printf ("compiling %s\n", showSMInsn (i)); --////
     
      -- This if removes unreachable code; otherwise
      -- the stack invariants for the symbolic interpreter
      -- are violated
      if env.isBarrier 
      then case i of
             LABEL (l, true) -> [env.dropBarrier, code <+ Label (l)]
           | LABEL (l, _)    -> if hasStack (env, l)
                                then [retrieveStack (env, l), code <+ Label (l)]
                                else [env, code]
                                fi
           | _               -> [env, code]
           esac
      else   
      case i of      
        BINOP(s) -> case s of
                      "+" -> simpleBinop("+", env, code)
                      | "-" -> simpleBinop("-", env, code)
                      | "*" -> mulBinop("*", env, code)
                      | "/" -> divModBinop (env, code, rax)
                      | "%" -> divModBinop (env, code, rdx)
                      | "==" -> compareBinop ("==", env, code)
                      | "!=" -> compareBinop ("!=", env, code)
                      | "<=" -> compareBinop ("<=", env, code)
                      | ">=" -> compareBinop (">=", env, code)
                      | "<" -> compareBinop ("<", env, code)
                      | ">" -> compareBinop (">", env, code)
                      | "!!" -> case pop2(env) of
                                  [x, y, env] -> case x of
                                      R(2) -> [push(env, rsi), code <+> withRDX(env, singletonBuffer(Binop("^", rax, rax)) <+ Binop("cmp", L(1), y) <+ Set(suffix("!="), "%al") <+ Binop("^", rsi, rsi) <+
                                    Binop("cmp", L(1), x) <+ Set(suffix("!="), "%sil") <+ Binop("!!", rax, rsi)) <+> toFixedNum(rsi)]
                                      | _ -> [push(env, y), code <+> withRDX(env, singletonBuffer(Binop("^", rax, rax)) <+ Binop("cmp", L(1), y) <+ Set(suffix("!="), "%al") <+ Binop("^", rdx, rdx) <+
                                    Binop("cmp", L(1), x) <+ Set(suffix("!="), "%dl") <+ Binop("!!", rax, rdx) <+ Mov(rdx, y)) <+> toFixedNum(y)]
                                    esac
                                esac
                      | "&&" -> case pop2(env) of
                                  [x, y, env] -> case x of
                                      R(2) -> [push(env, rsi), code <+> withRDX(env, singletonBuffer(Binop("^", rax, rax))
                                                <+ Binop("cmp", L(1), y) <+ Set(suffix("!="), "%al") <+ Binop("^", rsi, rsi) <+
                                                Binop("cmp", L(1), x) <+ Set(suffix("!="), "%sil") <+ Binop("&&", rax, rsi)) <+> toFixedNum(rsi)]
                                      | _ -> [push(env, y), code <+> withRDX(env, singletonBuffer(Binop("^", rax, rax))
                                        <+ Binop("cmp", L(1), y) <+ Set(suffix("!="), "%al") <+ Binop("^", rdx, rdx) <+
                                        Binop("cmp", L(1), x) <+ Set(suffix("!="), "%dl") <+ Binop("&&", rax, rdx) <+ Mov(rdx, y)) <+> toFixedNum(y)]
                                    esac
                                esac
                  esac
      | LD (x) -> let [s, env] = allocate(env) in [env, code <+> move (loc (env, x), s)]
      | LDA (x) ->  let [s, env] = allocate(env) in [env, code <+> leaHelper (env, loc (env, x), s)]
      | DROP -> [pop(env, "drop")[1], code]
      | DUP ->  case pop(env, "dup") of
                      [v, env] ->
                        case allocate(push(env, v)) of
                          [m, env] -> [env, code <+> move(v, m)]
                        esac
                esac
      | LABEL(l, _) -> [env, code <+ Label(l)]
      | CONST(n) -> case allocate(env) of
                      [s, env] -> [env, code <+ Mov(L(makeBox(n)), s)]
                    esac
      | ST (x) -> case pop(env, "st") of
                      [s, env] -> [push(env, loc (env, x)), code <+> move (s, loc (env, x))]
                  esac
      | JMP(l) -> [setBarrier(setStack(env, l)), code <+ Jmp(l)]
      | CJMP(cond, l) ->  case pop(env, "cjmp") of
                            [x, env] -> [setStack(env, l), code <+ Binop("cmp", L(1), x) <+ CJmp(cond, l)]
                          esac
      | CALL(f, n) -> case f[0] of
                        '$' ->
                          let [env, callCode] = call (env, sprintf ("L%s", substring(f, 1, f.length - 1)), n) in
                            [env, code <+> callCode]
                        | _ ->
                          let [env, callCode] = call (env, f, n) in
                            [env, code <+> callCode]
                      esac
      | GLOBAL(x) -> [addGlobal(env, x), code]
      | END ->  case epilogue(env) of
                  [env, epiCode] -> [env, code <+> epiCode]
                esac
      | BEGIN(f, a, l) -> [enterFunction(env, f, a, l), code <+> prologue(f)]
      | STRING(s) ->  case addString(env, s) of
                        [env, name] ->
                          let [ps, env] = allocate(env) in 
                            let [env, callCode] = call (env, "Bstring", 1) in
                              [env, (code <+> leaHelper (env, M(name), ps)) <+> callCode]
                      esac
      | ARRAY(n) ->
                      let [env, callCode] = call (env, "Barray", n + 1) in
                            [env, code <+> callCode]
      | STA ->  let [env, callCode] = call (env, "Bsta", 3) in
                      [env, code <+> callCode]
      | ELEM -> let [env, callCode] = call (env, "Belem", 2) in
                      [env, code <+> callCode]
      | SEXP(tag, n) -> let [sym, env] = addTag(env, tag) in
                        let [s, env] = allocate(env) in 
                          let [env, callCode] = call (env, "Bsexp", n + 2) in
                                [env, (code <+> leaHelper (env, M(sym), s)) <+> callCode]
      | PATT(p) -> 
                    case p of
                      Tag(t, n) -> 
                                    let [s, env] = allocate(env) in 
                                    let [ns, env] = allocate(env) in 
                                    let [env, callCode] = call (env, "Btag", 3) in
                                      [env, (code <+> leaHelper (env, M(tagSym(t)), s) <+> move(L(makeBox(n)), ns)) <+> callCode]
                      | Array(n) ->
                                    let [ns, env] = allocate(env) in 
                                    let [env, callCode] = call (env, "Barray_patt", 3) in
                                      [env, (code <+> move(L(makeBox(n)), ns)) <+> callCode]
                    esac
                    
      | META (m) ->
          case m of
            MF ([line, col]) -> 
              let [_   , env]     = env.pop("meta")      in
              let [s1  , env]     = env.allocate in
              let [s2  , env]     = env.allocate in                       
              let [env, callCode] = call (env, "Bmatch_failure", 2) in      
              [env.setBarrier, code <+ Mov (L (makeBox (line)), s1) <+ Mov (L (makeBox (col)), s2) <+> callCode]
          esac
	  
      (* Assignment        
         -- Some guidelines for generating function calls:
         --
         -- 1. generate instructions to save live registers on the X86 stack (use
         --    env.liveRegisters (number of arguments);
         -- 2. generate instructions to move actual parameters from the symbolic
         --    stack to the hardware one;
         -- 3. generate the call itself;
         -- 4. discard the actual parameters from the stack;
         -- 5. restore saved live registers.
         --
         -- Some guidelines for generating functions:
         --
         -- 1. generate proper prologue for BEGIN instruction (use "prologue" helper); use
         --    env.enterFunction to create a proper environment;
         -- 2. generate epilogue for END instruction.
       *)    
      | _ -> failure ("codegeneration for instruction %s is not yet implemented\n", i.string)
           
      esac
      fi
    }, [env, emptyBuffer ()], code)
}

fun simpleBinop (s, env, code) {
   case pop2(env) of
     [x, y, env] -> [push(env, y), (code <+ Dec(x)) <+> (if memOpnd(x) && memOpnd(y) then singletonBuffer(Mov(x, rax)) <+ Binop(s, rax, y) <+ Dec(s)
                                  else singletonBuffer(Binop(s, x, y))
                                  fi)]
   esac
}

fun mulBinop (s, env, code) {
  case pop2(env) of
     [x, y, env] -> [push(env, y), ((code <+ Sar1(x) <+ Sar1(y)) <+> (if memOpnd(y) then singletonBuffer(Binop(s, x, rax)) <+ Mov(rax, y)
                                  else singletonBuffer(Binop(s, x, y))
                                  fi)) <+> toFixedNum(y) ]
   esac
}

fun divModBinop (env, code, resMov) {
   case pop2(env) of
     [x, y, env] -> case x of
                      R(2) -> [push(env, y), (code <+ Sar1(x) <+ Sar1(y)) <+> withRDX(env, singletonBuffer(Mov(rsi, rax)) <+ Mov(rdx, rsi) <+ Cltd <+ IDiv(rsi) <+ Mov(resMov, rsi)) <+> toFixedNum(rsi)] -- y is rsi
                      | _ -> [push(env, y), (code <+ Sar1(x) <+ Sar1(y)) <+> withRDX(env, singletonBuffer(Mov(y, rax)) <+ Cltd <+ IDiv(x) <+ Mov(resMov, y)) <+> toFixedNum(y)]
                    esac
   esac
}

fun compareBinop (s, env, code) {
   case pop2(env) of
     [x, y, env] -> case x of
                      R(2) -> [push(env, y), code <+> withRDX(env, (singletonBuffer(Binop("^", rcx, rcx)) <+> (
                                              singletonBuffer(Binop("cmp", x, y))
                                              ) <+ Set(suffix(s), "%cl") <+ Mov(rcx, y)) <+> toFixedNum(y))]
                      | R(3) -> [push(env, y), code <+> withRDX(env, (singletonBuffer(Binop("^", r8, r8)) <+> (
                                              singletonBuffer(Binop("cmp", x, y))
                                              ) <+ Set(suffix(s), "%r8b") <+ Mov(r8, y)) <+> toFixedNum(y))]
                      | _ -> [push(env, y), code <+> withRDX(env, (singletonBuffer(Binop("^", rdx, rdx)) <+> (
                                              if memOpnd(x) && memOpnd(y)
                                                then singletonBuffer(Mov(x, rax)) <+ Binop("cmp", rax, y)
                                                else singletonBuffer(Binop("cmp", x, y))
                                              fi) <+ Set(suffix(s), "%dl") <+ Mov(rdx, y)) <+> toFixedNum(y))]
                    esac
   esac
}

-- A top-level codegeneration function. Takes a driver's environment and a stack machine program,
-- compiles the program into machine code, and compiles the machine code into an executable
public fun compileX86 (args, code) {
  case compile (args, initEnv (), code) of
    [env, code] ->
       var asmFile = getBaseName(args) ++ ".s",
           runtime = case getEnv ("LAMA_RUNTIME") of
                       #val  -> "../runtime64/"
                     | path  -> path
                     esac ++ "/runtime.o";
       
       fwrite (asmFile,
               map (insnString, 
                    getBuffer $
                      singletonBuffer (Meta ("\t.global\tmain\n")) <+>
                      dataSection (listBuffer (map (intDef   , getGlobals (env)))   <+>
                                   listBuffer (map (stringDef, getStrings (env))))  <+>                                  
		      codeSection (code)
                    ).stringcat);
                    
       system ({"gcc -g -o ", args.getBaseName, " ", runtime, " ", asmFile}.stringcat)
  esac
}
