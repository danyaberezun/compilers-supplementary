-- Expression evaluator

import List;
import Array;
import State;
import World;
import Lexer;
import Parser;
import Builtins;

-- As association map which maps "\otimes" into "\oplus"
var ops = {
  ["+" , infix + ],
  ["-" , infix - ],
  ["*" , infix * ],
  ["/" , infix / ],
  ["%" , infix % ],
  ["==", infix ==],
  ["!=", infix !=],
  ["<" , infix < ],
  ["<=", infix <=],
  [">" , infix > ],
  [">=", infix >=],
  ["&&", infix &&],
  ["!!", infix !!]
};

-- The evaluator for infix operators: takes an operator as a string
-- and two operand values, and returns the result
public fun evalOp (op, l, r) {
  case assoc (ops, op) of
    Some (f) -> f (l, r)
  esac
}

-- Evaluates an expression "expr" in a configuration "c".
-- A configuration is a pair of a state "s" and a world "w".
-- Returns a final configuration (if any)
--
-- A expression is represented by a data structure of the following shape:
--
-- expr = Assn    (string, expr)       |
--        Seq     (expr, expr)         |
--        Skip                         |
--        if      (expr, expr, expr)   |
--        While   (expr, expr)         |
--        DoWhile (expr, expr)         |
--        Var     (string)             |
--        Ref     (string)             |
--        Const   (int)                |
--        Binop   (string, expr, expr) |
--        Call    (string, expr list)  |
--        Ignore  (expr)               |
--        String  (string)             |
--        Array   (expr list)          |
--        Elem    (expr, expr)         |
--        ElemRef (expr, expr)         |
--        Sexp    (string, expr list)  |
--        Builtin (string, expr list)

-- Helper function: checks that given name designates a regular variable in
-- a given state
fun lookupVal (state, name) {
  case state.lookup (name) of
    x@Val (_) -> x
  | _         -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
  esac
}

-- Helper function: checks that given name designates a function in
-- a given state
fun lookupFun (state, name) {
  case state.lookup (name) of
    x@Fun (_, _) -> x
  | _            -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
  esac
}

-- Helper function: adds a bunch of regular variables current scope
fun addNames (state, names) {
  foldl (fun (s, name) {s.addName (name, Val (0))}, state, names)
}

-- Helper function: adds a function in current scope
fun addFunction (state, name, args, body) {
  state.addName (name, Fun (args, body))
}
                                        
-- Evaluates a list of expressions, properly threading a configurations.
-- Returns the final configuration and the list of values
fun evalList (c, exprs) {
  case foldl (fun ([c, vals], e) {
                case eval (c, e) of
                  [c, vl] -> [c, vl : vals]
                esac
              },
              [c, {}],
              exprs) of
    [c, vals] -> [c, reverse (vals)]
  esac
}

fun eval (c@[s, w], expr) {
  -- printf(">>> %s\n", string(expr));
  let result = case expr of
    Assn(ref, expr) ->
      let [c, ref] = eval(c, ref) in
      let [c@[s, w], value] = eval(c, expr) in
      case ref of
        VarRef(name) ->
          -- printf("%s = %s\n", string(name), string(value));
          [[s <- [name, value], w], value]
      | ElemRef(arr, index) ->
          case arr of
            #str -> arr[index] := value
          | #array -> arr[index] := value
          | Sexp(tag, items@#array) -> items[index] := value
          esac;
          [c, value]
      esac
  | Seq(expr1, expr2) ->
      let [c, Bottom] = eval(c, expr1) in
      eval(c, expr2)
  | Skip -> [c, Bottom]
  | If(cond, th, els) ->
      let [c, condVal@#val] = eval(c, cond) in
      if condVal then eval(c, th) else eval(c, els) fi
  | expr@While(cond, body) ->
      let [c, condVal@#val] = eval(c, cond) in
      if condVal then
        let [c, Bottom] = eval(c, body) in
        eval(c, expr)
      else
        [c, Bottom]
      fi
  | expr@DoWhile(body, cond) ->
      let [c, Bottom] = eval(c, body) in
      let [c, condVal@#val] = eval(c, cond) in
      if condVal then
        eval(c, expr)
      else
        [c, Bottom]
      fi
  | Var(name@#str) -> [c, lookup(s, name)]
  | Ref(name@#str) -> [c, VarRef(name)]
  | Const (value@#val) -> [c, value]
  | Binop (op, lhs, rhs) ->
      let [c, x] = eval(c, lhs) in
      let [c, y] = eval(c, rhs) in
      [c, case op of
        "+" -> x + y
      | "-" -> x - y
      | "*" -> x * y
      | "/" -> x / y
      | "%" -> x % y
      | "<" -> x < y
      | ">" -> x > y
      | "<=" -> x <= y
      | ">=" -> x >= y
      | "==" -> x == y
      | "!=" -> x != y
      | "&&" -> x && y
      | "!!" -> x !! y
      esac]
  | Ignore(expr) ->
      let [c, _] = eval(c, expr) in
      [c, Bottom]
  | Scope(defs, expr) ->
      let s = enterScope(s) in
      let s = foldl (fun (s, d) {
        case d of
          Var(names) -> addNames(s, names)
        | Fun(name, args, body) -> addFunction(s, name, args, body)
        esac
      }, s, defs) in
      -- printf("%s\n%s\n%s\n", string(defs), string(expr), string(s));
      let [[s, w], value] = eval([s, w], expr) in
      let s = leaveScope(s) in
      [[s, w], value]
  | Call(name, args) ->
      let Fun(argNames, body) = lookup(s, name) in
      if size(argNames) != size(args) then
        error (sprintf ("function ""%s"" expects %d arguments, but got %d", name, size(argNames), size(args)), getLoc(name))
      fi;
      let [c@[s, w], args] = foldr(fun ([c, computed], arg) {
        let [c@[s, w], arg] = eval(c, arg) in
        [c, arg:computed]
      }, [c, {}], args) in
      let sInitial = s in
      let s = enterFunction(s) in
      let s = foldr(fun (s, [name, arg]) {
        addName(s, name, arg)
      }, s, zip(argNames, args)) in
      let [[s, w], ret] = case body of
        External -> let [x, w] = evalBuiltin(name, args, w) in [[s, w], x]
      | _ -> eval([s, w], body)
      esac in
      let s = leaveFunction(sInitial, getGlobal(s)) in
      [[s, w], ret]
  | String(s@#str) -> [c, s]
  | Elem(arr, index) ->
      let [c, arr] = eval(c, arr) in
      let [c, index] = eval(c, index) in
      case arr of
        a@#array -> [c, a[index]]
      | s@#str -> [c, s[index]]
      | s@Sexp(_, items@#array) -> [c, items[index]]
      esac
  | ElemRef(arr, index) ->
      let [c, arr] = eval(c, arr) in
      let [c, index] = eval(c, index) in
      case arr of
        a@#array -> [c, ElemRef(a, index)]
      | s@#str -> [c, ElemRef(s, index)]
      esac
  | Array(items) ->
      let [c, items] = foldr (fun ([c, items], item) {
        let [c, item] = eval(c, item) in
        [c, item : items]
      }, [c, {}], items) in
      [c, listArray(items)]
  | Sexp(name, items) ->
      let [c, items] = foldr (fun ([c, items], item) {
        let [c, item] = eval(c, item) in
        [c, item : items]
      }, [c, {}], items) in
      [c, Sexp(name, listArray(items))]
  esac in
  -- printf("%s: %s\n", string(expr), string(result));
  result
}

-- Evaluates a program with a given input and returns an output
public fun evalExpr (input, expr) {
  case eval ([emptyState ().enterScope.addName ("read",   Fun ({}, External))
                                      .addName ("write",  Fun ({"a"}, External))
                                      .addName ("length", Fun ({"a"}, External)), createWorld (input)], expr) of
    [c, _] -> c.snd.getOutput
  esac
}
