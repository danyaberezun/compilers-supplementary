-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} 
                                | x=lident  {Var (x)}               
                                | inbr[s("("), exp, s(")")]),
    add_exp = memo $ eta syntax (x=mul_exp {x} 
                              | l=add_exp b=(s["+"] {"+"}
                                         | s["-"] {"-"}) r=mul_exp {Binop(b, l, r)}),
    mul_exp = memo $ eta syntax (x=primary {x} 
                             | l=mul_exp b=(s["*"] {"*"}
                                        | s["/"] {"/"} 
                                        | s["%"] {"%"}) r=primary {Binop(b, l, r)}),
    cmp_exp = memo $ eta syntax (x=add_exp {x}
                                | l=cmp_exp b=(s["=="] {"=="}
                                              | s["!="] {"!="}
                                              | s[">"] {">"}
                                              | s["<"] {"<"}
                                              | s[">="] {">="}
                                              | s["<="] {"<="}) r=add_exp {Binop(b, l, r)}),
                         
    exp = memo $ eta syntax (x=and_exp {x} 
                            | l=exp s["!!"] r=and_exp {Binop("!!", l, r)}),
    and_exp = memo $ eta syntax (x=cmp_exp {x} 
                                | l=and_exp s["&&"] r=cmp_exp {Binop("&&", l, r)}),
    pIf_exp =  memo $ eta syntax ( kFi {Skip} 
                                 | kElse s = stmt kFi {s}
                                 | kElif e = exp kThen s = stmt p = pIf_exp {If (e, s, p)});
    
var prev_stmt = memo $ eta syntax (
  kSkip                                   {Skip} 
  | varName  = lident s[":="] value = exp   {Assn (varName, value)} 
  | kRead x  = inbr[s("("), lident, s(")")] {Read (x)} 
  | kWrite e = inbr[s("("), exp, s(")")]    {Write (e)}
  | kIf e = exp kThen s1 = stmt s2 = pIf_exp {If (e, s1, s2)}
  | kWhile e = exp kDo s = stmt kOd      {While (e, s)}
  | kDo s = stmt kWhile e = exp kOd      {DoWhile (s, e)}
  | kFor s1 = stmt s[","] e = exp s[","] s2 = stmt kDo s3 = stmt kOd {Seq (s1, While (e, Seq (s3, s2)))});


var stmt = memo $ eta syntax (
  prev_stmt
  | stmt1 = prev_stmt s[";"] stmt2 = stmt {Seq (stmt1, stmt2)}
);

-- Public top-level parser
public parse = stmt;
