-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun par(p) {
	inbr(s("("), p, s(")"))
}

fun mapBinop(left, op, right) { Binop(op, left, right) }

fun binop(assoc, ops) {
	[assoc, map (fun(op) { [s(op), mapBinop] }, ops)]
}

fun binops(aops) {
	map (fun ([assoc, ops]) { binop(assoc, ops) }, aops)
}

-- Primary expression
var primary = memo $ eta syntax (
	  x=decimal {Const (stringInt (x))} 
	| x=lident  {Var (x)}               
	| par[exp]
	),
    exp = memo $ eta (expr (binops ({
       [Left, {"!!"}],
       [Left, {"&&"}],
       [Nona, {"==", "<", ">", "!=", ">=", "<="}],
       [Left, {"+", "-"}],
       [Left, {"*", "/", "%"}]
    }), primary));
var elseBody = memo $ eta syntax (
        kElse elseSt=stmt kFi { elseSt }
      | kElif ifSt=ifBody { ifSt }
      | kFi { Skip }
    ),
    ifBody = memo $ eta syntax (
    	expr=exp kThen thenSt=stmt elseSt=elseBody { If (expr, thenSt, elseSt) }
    );
var stmtOnce = memo $ eta syntax (
	  kRead x=par[lident] { Read (x) }
	| kWrite x=par[exp]  { Write (x) }
	| kSkip { Skip }
	| x=lident s[":="] a=exp { Assn (x, a) }
	| kIf ifSt=ifBody { ifSt }
	| kWhile cond=exp kDo act=stmt kOd { While (cond, act) }
	| kDo act=stmt kWhile cond=exp kOd { DoWhile (act, cond) }
	| kFor init=stmt s[","] cond=exp s[","] iter=stmt kDo act=stmt kOd 
	  { Seq (init, While (cond, Seq (act, iter))) }
	),
    stmt = memo $ eta syntax (
	  stmtOnce
	| a=stmtOnce s[";"] b=stmt { Seq (a, b) }
	);

-- Public top-level parser
public parse = stmt;
