-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp0, s(")")]),
    exp0 = memo $ eta syntax (x=exp1 {x} |
                              l=exp0 s["!!"] r=exp1 {Binop("!!", l, r)}),
    exp1 = memo $ eta syntax (x=exp2 {x} |
                              l=exp1 s["&&"] r=exp2 {Binop("&&", l, r)}),
    exp2 = memo $ eta syntax (x=exp3 {x} |
                              l=exp2 b=eq_priority_binops r=exp3 {Binop(b, l, r)}),
    exp3 = memo $ eta syntax (x=exp4 {x} |
                              l=exp3 b=add_priority_binops r=exp4 {Binop(b, l, r)}),
    exp4 = memo $ eta syntax (x=primary {x} |
                              l=exp4 b=mul_priority_binops r=primary {Binop(b, l, r)}),
    mul_priority_binops = memo $ eta syntax( b=(s["*"] | s["%"] | s["/"]) {b} ),
    add_priority_binops = memo $ eta syntax( b=(s["-"] | s["+"]) {b} ),
    eq_priority_binops = memo $ eta syntax( b=(s["<"] | s[">"] | s["<="] | s[">="] | s["=="] | s["!="]) {b} );

var stmts = memo $ eta syntax (
  st=stmt {st} |
  l=stmt s[";"] r=stmts {Seq (l, r)}
),

stmt = memo $ eta syntax (
  vn=lident s[":="] exp=exp0 {Assn (vn, exp)} |
  kRead s["("] l=lident s[")"] {Read (l)} |
  kWrite s["("] exp=exp0 s[")"] {Write (exp)} |
  kSkip {Skip} |
  w1=kIf exp=exp0 w2=kThen s=stmts end=endIf {If (exp, s, end)} | 
  w1=kWhile exp=exp0 w2=kDo s=stmts w3=kOd {While (exp, s)} |
  w1=kDo s=stmts w2=kWhile exp=exp0 w3=kOd {DoWhile (s, exp)} | 
  w1=kFor initial=stmts s[","] condition=exp0 s[","] incr=stmts w2=kDo body=stmts w3=kOd {Seq(initial, While(condition, Seq(body, incr)))}
),

endIf = memo $ eta syntax (
  w1=kElse s=stmts w2=kFi {s} |
  w1=kElif exp=exp0 w2=kThen s=stmts end=endIf {If (exp, s, end)} |
  w1=kFi {Skip}
)
;
   

-- Public top-level parser
public parse = stmts;
