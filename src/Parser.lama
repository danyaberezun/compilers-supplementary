-- Parser 



import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    t_bf = fun(l, op, r) { Binop(op, l, r) },
    exp = memo $ expr({
        [
            Left,
            {[s("!!"), t_bf]}
        ],
        [
            Left,
            {[s("&&"), t_bf]}
        ],
        [
            Nona,
            {
                [s("=="), t_bf],
                [s("!="), t_bf], 
                [s("<="), t_bf], 
                [s(">="), t_bf], 
                [s("<"), t_bf], 
                [s(">"), t_bf]
            }
        ],
        [
            Left, 
            {
                [s("+"), t_bf], 
                [s("-"), t_bf]
            }
        ],
        [
            Left, 
            {
                [s("*"), t_bf], 
                [s("/"), t_bf], 
                [s("%"), t_bf]
            }
        ]
    }, primary);

var stmt1 = eta syntax (
        kWrite y=inbr[s("("), exp, s(")")] { Write(y) } |
        kSkip { Skip } |
        y=lident s[":="] x=exp { Assn(y, x) } |
        kRead x=inbr[s("("), lident, s(")")] { Read(x) } |
        kIf con=exp kThen s1=stmt s2=postIf { If(con, s1, s2) } | 
        kWhile con=exp kDo s=stmt kOd { While(con, s) } |
        kDo s=stmt kWhile con=exp kOd { DoWhile(s, con) } |
        kFor s1=stmt s[","] con=exp s[","] s2=stmt kDo s3=stmt kOd { Seq(s1, While(con, Seq(s3, s2))) } 
    ),
    postIf =  memo $ eta syntax (
        kElif con=exp kThen s1=stmt e=postIf { If(con, s1, e) } |
        kElse s1=stmt kFi { s1 } |
        kFi { Skip }
    ),
    stmt = memo $ eta syntax (stmt1 | x=stmt1 s[";"] xs=stmt { Seq (x, xs) } 
);
   

-- Public top-level parser
public parse = stmt;
             