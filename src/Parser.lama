-- Parser 
import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
   syntax (-l p -r)
}
fun inpr (op) {
   [s(op), fun (l, op, r) {Binop(op, l, r)}]
}
-- Primary expression
var primary = memo $ eta syntax (
                       x=decimal {Const(stringInt(x))} |
                       
                       x=lident {Var(x)} |
                       
                       inbr[s("("), exp, s(")")]
                     ),
    exp     = memo $ eta (
                   expr({[Left, map(inpr, {"!!", "&&"})],
                      [Nona, map(inpr, {"==", "!=", "<", "<=", ">", ">="})],
                      [Left, map(inpr, {"+", "-"})],
                      [Left, map(inpr, {"*", "/", "%"})]}, primary)
                ),
    stmt    = memo $ eta syntax (
                             varName=lident s[":="] value=exp {Assn(varName, value)} |
                             
                             kSkip {Skip} |
                             
                             kRead x=inbr[s("("), lident, s(")")] {Read(x)} |
                             
                             kWrite e=inbr[s("("), exp, s(")")] {Write(e)} |
                             
                             kIf expr=exp kThen first=program second=ifCont {If(expr, first, second)} |
                             
                             kWhile expr=exp kDo inner=program kOd {While(expr, inner)} |
                             
                             kDo inner=program kWhile expr=exp kOd {DoWhile(inner, expr)} |
                             
                             kFor pre=stmt s[","] expr=exp s[","] post=stmt kDo inner=program kOd {
                                Seq(pre, While(expr, Seq(inner, post)))
                             }
                           ),
    ifCont  = memo $ eta syntax (
      kFi {Skip} |
      
      -kElse program -kFi |
      
      kElif expr=exp kThen first=program second=ifCont {If(expr, first, second)}
    ),
    program = memo $ eta syntax (
      first=stmt s[";"] second=program {Seq(first, second)} |
      
      stmt
    );
-- Public top-level parser
public parse = program;