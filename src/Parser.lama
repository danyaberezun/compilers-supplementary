-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inbkts (p) {
  inbr (s("("), p, s(")"))
}

fun makeBinop (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (
      x=decimal {Const (stringInt (x))}
    | x=lident  {Var (x)}
    | inbkts[exp]
    ),
    exp = memo $ eta (expr (
      {
        [Left, {[orOp, makeBinop]}],
        [Left, {[andOp, makeBinop]}],
        [Nona, {[comparativeOp, makeBinop]}],
        [Left, {[additiveOp, makeBinop]}],
        [Left, {[multiplicativeOp, makeBinop]}]
      },
      primary
    ));

var singleStmt = memo $ eta syntax (
      kRead x=inbkts[lident] { Read (x) }
    | kWrite e=inbkts[exp] { Write (e) }
    | kSkip { Skip }
    | x=lident assignOp e=exp { Assn (x, e) }
    | kIf cond=exp kThen pbr=stmt 
        brs=(kElif condi=exp kThen bri=stmt { Br (condi, bri) })* 
        nbr=(-kElse nbr=stmt)? kFi
         {
          let cont = foldl (
            fun (cont, Br (cond, br)) { fun (x) { cont (If (cond, br, x)) } },
            fun (x) { If (cond, pbr, x) },
            brs
          ) in 
            case nbr of 
              Some (nbr) -> cont (nbr)
            | _          -> cont (Skip)
            esac
      }
    | kWhile cond=exp kDo body=stmt kOd { While (cond, body) }
    | kDo body=stmt kWhile cond=exp kOd { DoWhile (cond, body) }
    | kFor ini=stmt comma cond=exp comma upd=stmt kDo body=stmt kOd { 
        Seq (ini, While (cond, Seq (body, upd)))
      }
    ),
    stmt = memo $ eta syntax (s1=singleStmt semicolon s2=stmt { Seq (s1, s2) } | singleStmt);
   

-- Public top-level parser
public parse = stmt;
