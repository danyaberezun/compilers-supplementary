-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]);

fun constructLevel(op) {
   [s(op), fun (l, op, r){Binop(op, l ,r)}]
}

-- precedence from the spec
var ops = {
  [Left, map(constructLevel, {"!!"})],
  [Left, map(constructLevel, {"&&"})],
  [Nona, map(constructLevel, {"==", "!=", "<=", "<", ">=", ">"})],
  [Left, map(constructLevel, {"+", "-"})],
  [Left, map(constructLevel, {"*", "/", "%"})]
};

var exp = memo $ eta expr(ops, primary);

var stmt = memo $ eta syntax(
  varname=lident s[":="] expr_=exp {Assn(varname, expr_)} | 
  stmt1=stmt s[";"] stmt2=stmt end {Seq(stmt1, stmt2)} | 
  kSkip {Skip} | 
  kRead varname=inbr[s("("), lident, s(")")] {Read(varname)} | 
  kWrite expr_=inbr[s("("), exp, s(")")] {Write(expr_)}
);
   

-- Public top-level parser
public parse = stmt;
