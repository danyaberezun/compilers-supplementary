-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun doBinop (l, op, r) {
    Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
        exp = memo $ eta expr ({
          [Left, {
            [s ("&&"), doBinop],
            [s ("!!"), doBinop]
          }],
          [Nona, {
            [s ("=="), doBinop],
            [s ("!="), doBinop],
            [s (">"),  doBinop],
            [s (">="), doBinop],
            [s ("<"),  doBinop],
            [s ("<="), doBinop]
          }],
          [Left, {
            [s ("+"), doBinop],
            [s ("-"), doBinop]
          }],
          [Left, {
            [s ("/"), doBinop], 
            [s ("%"), doBinop], 
            [s ("*"), doBinop]
          }]
        }, primary);

var parseStmt = memo $ eta syntax (
    kSkip {Skip}
  | kRead x = inbr[s("("), lident, s(")")] { Read (x) }
  | kWrite x = inbr[s("("), exp, s(")")] { Write (x) }
  | x = lident s[":="] e = exp { Assn (x, e) }
);

var stmt = memo $ eta syntax (
  parseStmt
  | head = parseStmt s[";"] tail = stmt { Seq (head, tail) } 
);

-- Public top-level parser
public parse = stmt;
