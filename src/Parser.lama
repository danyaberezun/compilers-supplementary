-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    f = fun (p) {[s (p), fun (l, p, r) {Binop (p, l, r)}]},
    exp = memo $ eta (expr ({[Left, map(f, {"!!", "&&"})],
                             [Nona, map(f, {"==", "!=", "<", "<=", ">", ">="})],
                             [Left, map(f, {"+", "-"})],
                             [Left, map(f, {"*", "/", "%"})]}, primary));
var ifExpr = memo $ eta syntax (
    kFi {Skip} 
    | -kElse stmt -kFi
    | kElif e=exp kThen e1=stmt e2=ifExpr {If (e, e1, e2)}
  ),
  stmtOne = memo $ eta syntax (
    kRead name=inbr[s("("), lident, s(")")] {Read (name)}
    | kWrite e=inbr[s("("), exp, s(")")]   {Write (e)}
    | kSkip { Skip }
    | name=lident s[":="] e=exp {Assn (name, e)}
    | kIf e=exp kThen e1=stmt e2=ifExpr {If (e, e1, e2)}
    | kWhile e=exp kDo body=stmt kOd {While (e, body)}
    | kDo body=stmt kWhile e=exp kOd { DoWhile (e, body) }
    | kFor i=stmtOne s[","] e=exp s[","] upd=stmtOne kDo body=stmt kOd { 
        Seq (i, While (e, Seq (body, upd)))
      }
  ),
  stmt = memo $ eta syntax (e1=stmtOne s[";"] e2=stmt {Seq (e1, e2)} | stmtOne);   

-- Public top-level parser
public parse = stmt;
