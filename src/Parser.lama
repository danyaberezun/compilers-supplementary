-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (l, op, r) { 
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr (
        {
          [Left, {[s("!!"), binop]}],

          [Left, {[s("&&"), binop]}],

          [Nona, {[s("=="), binop],
                  [s("!="), binop],
                  [s("<="), binop],
                  [s("<"), binop],
                  [s(">="), binop],
                  [s(">"), binop]}],

          [Left, {[s("+"), binop],
                  [s("-"), binop]}],

          [Left, {[s("*"), binop],
                  [s("/"), binop],
                  [s("%"), binop]}]
        },
        primary
      ));

var ifStmtTail = memo $ eta syntax (
  kFi {Skip} |
  kElse s=stmt kFi {s} |
  kElif c=exp kThen s=stmt e=ifStmtTail {If (c, s, e)}
);

var statement = memo $ eta syntax (
  kSkip {Skip} |
  kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
  kWrite x=inbr[s("("), exp, s(")")] {Write (x)} |
  x=lident s[":="] e=exp {Assn (x, e)} |
  kIf c=exp kThen s=stmt e=ifStmtTail {If (c, s, e)} |
  kWhile c=exp kDo s=stmt kOd {While (c, s)} |
  kDo s=stmt kWhile c=exp kOd {DoWhile (s, c)} |
  kFor init=stmt s[","] cond=exp s[","] step=stmt kDo body=stmt kOd {
    Seq(init, While(cond, Seq(body, step)))
  }
);

var stmt = memo $ eta syntax (
  statement | s1=statement s[";"] s2=stmt {Seq(s1, s2)}
);

-- Public top-level parser
public parse = stmt;
