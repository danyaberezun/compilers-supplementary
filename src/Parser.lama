-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Binary operation constructor
fun operatorBuilder (leftSide, operation, rightSide) {
  Binop (operation, leftSide, rightSide)
}

-- Primary expressions
var basicElement = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                     x=lident  {Var (x)}               |
                                     inbr[s("("), expression, s(")")]),
    
    expression = memo $ expr ({
      [Left, {[s ("!!"), operatorBuilder]}],
      [Left, {[s ("&&"), operatorBuilder]}],
      [Nona, {[s ("=="), operatorBuilder], [s ("!="), operatorBuilder],
              [s ("<="), operatorBuilder], [s ("<"), operatorBuilder],
              [s (">="), operatorBuilder], [s (">"), operatorBuilder]}],
      [Left, {[s ("+"), operatorBuilder], [s ("-"), operatorBuilder]}],
      [Left, {[s ("*"), operatorBuilder], [s ("/"), operatorBuilder], [s ("%"), operatorBuilder]}]
    }, basicElement);

-- Statements
var command = memo $ eta syntax (
  kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
  kWrite x=inbr[s("("), expression, s(")")] {Write (x)} |
  kSkip {Skip} |
  x=lident s[":="] e=expression {Assn (x, e)}
);

-- Program structure
var sequence = memo $ eta syntax (
  command | 
  first=command s[";"] remaining=sequence {Seq (first, remaining)}
);

-- Public top-level parser
public parse = sequence;
             
