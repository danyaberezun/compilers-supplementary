-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} 
                                | x=lident  {Var (x)}               
                                | inbr[s("("), exp, s(")")]),
    exp = memo $ eta syntax (x=and_exp {x} 
                            | l=exp s["!!"] r=and_exp {Binop("!!", l, r)}),
    and_exp = memo $ eta syntax (x=cmp_exp {x} 
                                | l=and_exp s["&&"] r=cmp_exp {Binop("&&", l, r)}),
    cmp_exp = memo $ eta syntax (x=add_exp {x}
                                | l=cmp_exp b=(s["=="] {"=="}
                                              | s["!="] {"!="}
                                              | s[">"] {">"}
                                              | s["<"] {"<"}
                                              | s[">="] {">="}
                                              | s["<="] {"<="}) r=add_exp {Binop(b, l, r)}),
    add_exp = memo $ eta syntax (x=mul_exp {x} 
                              | l=add_exp b=((s["+"] {"+"}) 
                                         | (s["-"] {"-"})) r=mul_exp {Binop(b, l, r)}),
    mul_exp = memo $ eta syntax (x=primary {x} 
                             | l=mul_exp b=((s["*"] {"*"}) 
                                        | (s["/"] {"/"}) 
                                        | (s["%"] {"%"})) r=primary {Binop(b, l, r)});

var prev_stmt = memo $ eta syntax (
  kSkip                                   {Skip} 
  | varName  = lident s[":="] value = exp   {Assn (varName, value)} 
  | kRead x  = inbr[s("("), lident, s(")")] {Read (x)} 
  | kWrite e = inbr[s("("), exp, s(")")]    {Write (e)}
);

var stmt = memo $ eta syntax (
  prev_stmt
  | stmt1 = prev_stmt s[";"] stmt2 = stmt {Seq (stmt1, stmt2)}
);

-- Public top-level parser
public parse = stmt;
             
