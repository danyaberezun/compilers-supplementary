-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression

var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    binop = fun(l, op, r) {Binop(op, l, r)},
    exp = memo $ expr({
      [Left, {
        [s("^"), binop]
      }],
      [Left, {
        [s("!!"), binop]
      }],
      [Left, {
        [s("&&"), binop]
      }],
      [Nona, {
        [s("<"), binop],
        [s("<="), binop],
        [s("=="), binop],
        [s("!="), binop],
        [s(">="), binop],
        [s(">"), binop]
      }],
      [Left, {
        [s("+"), binop],
        [s("-"), binop]
      }],
      [Left, {
        [s("*"), binop],
        [s("/"), binop],
        [s("%"), binop]
      }]
    }, primary);

var stmt_part = memo $ eta syntax(v=lident s[":="] e=exp{Assn(v, e)}
                                 |kSkip{Skip}
                                 |kRead v=inbr[s("("), lident, s(")")] {Read(v)}
                                 |kWrite e=inbr[s("("), exp, s(")")] {Write(e)}
                                 ),
    stmt = memo $ eta syntax(f=stmt_part s[";"] r=stmt{ Seq(f, r) }
                            |s=stmt_part{s}
                            );

-- Public top-level parser
public parse = stmt;             
