-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun infixParser (op) {
  [s (op), fun (l, op, r) {Binop (op, l, r)}]
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (expr ({[Left, map (infixParser, {"!!", "&&"})],
                             [Nona, map (infixParser, {"==", "!=", "<", "<=", ">", ">="})],
                             [Left, map (infixParser, {"+", "-"})],
                             [Left, map (infixParser, {"*", "/", "%"})]}, primary)),

    stmt = memo $ eta syntax (name=lident s[":="] expr=exp                 {Assn (name, expr)}        |
                              kSkip                                        {Skip}                     |
                              kRead name=inbr[s("("), lident, s(")")]      {Read (name)}              |
                              kWrite expr=inbr[s("("), exp, s(")")]        {Write (expr)}             |
                              kIf expr=exp kThen first=program second=ifCont {If (expr, first, second)} |
                              kWhile expr=exp kDo inner=program kOd          {While (expr, inner)}      |
                              kDo inner=program kWhile expr=exp kOd          {DoWhile (inner, expr)}    |
                              kFor pre=stmt s[","] expr=exp s[","] post=stmt kDo inner=program kOd {
                                Seq (pre, While (expr, Seq (inner, post)))
                              }),

    program = memo $ eta syntax (first=stmt s[";"] second=program {Seq (first, second)} | stmt),

    ifCont = memo $ eta syntax (kFi {Skip} |
                                -kElse program -kFi |
                                kElif expr=exp kThen first=program second=ifCont {If (expr, first, second)});
   

-- Public top-level parser
public parse = program;