-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression

var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
        { [Left, {[s ("!!"), fun (l , op , r) {Binop (op, Binop("!=", Const(0), l) , Binop("!=", Const(0), r)  )}]
                  }], 
          [Left, {[s ("&&"), fun (l , op , r) {Binop (op, Binop("!=", Const(0), l) , Binop("!=", Const(0), r))}]
                  }],        
          [Nona, {[s ("!=") | s ("==") | s ("<=") | s ("<") | s (">=") | s (">"), fun(l, op, r) {Binop (op, l, r)}]
                  }],
          [Left , {[s ("+"), fun (l , op , r) {Binop (op, l , r)}] ,
                  [s ("-"), fun (l , op , r) {Binop (op, l , r)}]
                  }],
         [Left , {[s ("*"), fun (l , op , r) {Binop (op, l , r)}] ,
                  [s ("/") | s ("%"), fun (l , op , r) {Binop (op, l , r)}] 
                  }]

        }, primary);

var ifcheck = memo $ eta syntax (
  x=exp kThen y=stmt                 {If(x, y, Skip)}
  | x=exp kThen y=stmt kElse z=stmt    {If(x, y, z)}
  | x=exp kThen y=stmt kElif z=ifcheck {If(x, y, z)}
); 


var check = memo $ eta syntax (
    x=lident s[":="] y=exp                                {Assn(x, y)}
  | kRead x=inbr[s("("), lident, s(")")]                  {Read (x)}
  | kWrite x=inbr[s("("), exp, s(")")]                    {Write (x)}
  | kSkip                                                 {Skip}
  | kIf x=exp kThen y=stmt  kFi                           {If(x, y, Skip)}
  | kIf x=exp kThen y=stmt  kElse z=stmt kFi              {If(x, y, z)} 
  | kIf x=exp kThen y=stmt  kElif z=ifcheck kFi           {If(x, y, z)}
  | kWhile x=exp kDo y=stmt kOd                           {While(x, y)}
  | kDo x=stmt kWhile y=exp kOd                           {DoWhile(x, y)}
  | kFor c1=check s[","] e=exp s[","] c2=check kDo c3=stmt kOd  {Seq(c1, While(e, Seq(c3, c2)))}
);


var stmt = memo $ eta syntax (
  x=check s[";"] y=stmt {Seq (x, y)}
  | x=check {x}
);

-- Public top-level parser
public parse = stmt;