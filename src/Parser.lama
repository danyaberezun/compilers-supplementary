-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                inbr[s("("), exp, s(")")]),
    f = fun(l, op, r) { Binop(op, l, r) },
    exp = memo $ expr({
        [Left, {[s("!!"), f]}],
        [Left, {[s("&&"), f]}],
        [Nona, {[s("<"), f], [s(">"), f], [s("<="), f], [s(">="), f], [s("=="), f], [s("!="), f]}],
        [Left, {[s("+"), f], [s("-"), f]}],
        [Left, {[s("*"), f], [s("/"), f], [s("%"), f]}]
    }, primary);

var statement = memo $ eta syntax (
    kSkip {Skip} |
    varName=lident s[":="] value=exp {Assn (varName, value)} |
    kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
    kWrite e=inbr[s("("), exp, s(")")] {Write (e)} |
    kIf x=exp kThen s=stmt cont=ifCont { If(x, s, cont) } |
    kWhile x=exp kDo s=stmt kOd { While(x, s) } |
    kDo s=stmt kWhile x=exp kOd { DoWhile(s, x) } |
    kFor init=stmt s[","] cond=exp s[","] inc=stmt kDo body=stmt kOd { Seq(init, While(cond, Seq(body, inc))) }
),
ifCont = memo $ eta syntax (
    kElif x=exp kThen s=stmt cont=ifCont { If(x, s, cont) }
    | kElse s=stmt kFi { s }
    | kFi { Skip }
);

var stmt = memo $ eta syntax (
    statement | s1=statement s[";"] s2=stmt {Seq (s1, s2)}
);

-- Public top-level parser
public parse = stmt;
