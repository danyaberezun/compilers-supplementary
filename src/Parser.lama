-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

fun ref (atr, v, loc) {
	case atr of
      Ref  -> Ref (v)
    | Void -> Ignore (Var (v))
    | _    -> Var (v)
    esac
}

fun par(p) {
	inbr(s("("), p, s(")"))
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

fun bops(aops) {
  map (fun ([assoc, ops]) { [assoc, map (binop, ops)] }, aops)
}

var assignOp =  [Right, 
					{[
					s (":="), 
					fun (l, loc, r) {
                        fun (a) {
                        	assertValue (a, Assn (l (Ref), r (Val)), loc)
                        }
                    }
                    ]}
            	];
var elseBody = memo $ eta syntax (
        loc=pos kElse elseSt=exp kFi { 
        	fun(a) {
        		elseSt (a)
        	}
        }
      | loc=pos kElif ifSt=ifBody { 
      		fun (a) {
      			ifSt (a)
      		}
        }
      | loc=pos kFi { 
        	fun (a) {
        		assertVoid (a, Skip, loc)
        	}
       }
    ),
    ifBody = memo $ eta syntax (
    	loc=pos cond=exp kThen thenB=exp elseB=elseBody { 
    		fun (a) {
    			If (cond (Val), thenB (a), elseB (a))
    		}
    	}
    );

var primary = memo $ eta syntax (
								  par[exp]
								| loc=pos kSkip { -- Skip
								  	fun (a) {
								   		assertVoid (a, Skip, loc)
								   	}
								  }
								| loc=pos kRead x=par[lident] { -- Read (x)
									fun (a) {
										assertVoid (a, Ignore (Read (x)), loc)
									}
								  }
								| loc=pos kWrite v=par[exp] { -- Write (v)
									fun (a) {
										assertVoid (a, Write (v (Val)), loc)
									}
								  }
								| loc=pos kIf body=ifBody {	-- If
									fun (a) {
										body (a)
									}
								  }
								| loc=pos kWhile cond=exp kDo x=exp kOd { -- While (cond, x)
									fun (a) {
										assertVoid (a, While(cond (Val), x (Void)), loc)
									}
								  }
								| loc=pos kFor x=exp s[","] cond=exp s[","] z=exp kDo y=exp kOd { -- x;While (cond, y;z)
									fun (a) {
										assertVoid (
											a,
											Seq (x (Void), While(cond (Val), Seq (y (Void), z (Void)))),
											loc
										)
									}
								 }
								| loc=pos kDo x=exp kWhile cond=exp kOd { -- DoWhile(x, cond)
									fun (a) {
										assertVoid (a, DoWhile(x (Void), cond (Val)), loc)
									}
								  }
								| loc=pos x=lident { -- Var (x) / Ref(x)
                                	fun(a) { 
                                		ref (a, x, loc) 
                                	} 
                                  }
                                | loc=pos n=decimal { -- Const (n)
                                 	fun (a) { 
                                 		assertValue (a, Const (stringInt (n)), loc) 
                                 	} 
                                  }
                                ),
    basic    = memo $ eta (expr (assignOp : bops({
                                  [Left, {"!!"}],
                                  [Left, {"&&"}],
                                  [Nona, {"==", "!=", "<", ">", "<=", ">="}],
                                  [Left, {"+", "-"}],
                                  [Left, {"*", "/", "%"}]
                                 }),
                                 primary)),
    exp = memo $ eta syntax (basic | s1=basic s[";"] s2=exp {fun (a) {Seq (s1 (Void), s2 (a))}});

-- Public top-level parser
public parse = syntax (s=exp {s (Void)});
