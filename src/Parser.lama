-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
        { [Left, { [s ("!!"), fun (l, op, r) { Binop (op, l, r) }],
                   [s ("&&"), fun (l, op, r) { Binop (op, l, r) }]}],
          [Nona, { [s (">"),  fun (l, op, r) { Binop (op, l, r) }],
                   [s (">="), fun (l, op, r) { Binop (op, l, r) }],
                   [s ("<"),  fun (l, op, r) { Binop (op, l, r) }],
                   [s ("<="), fun (l, op, r) { Binop (op, l, r) }],
                   [s ("=="), fun (l, op, r) { Binop (op, l, r) }],
                   [s ("!="), fun (l, op, r) { Binop (op, l, r) }]
                 }],
          [Left, { [s ("+"),  fun (l, op, r) { Binop (op, l, r) }],
                   [s ("-"),  fun (l, op, r) { Binop (op, l, r) }]
                 }],
          [Left, { [s ("*"),  fun (l, op, r) { Binop (op, l, r) }],
                   [s ("/"),  fun (l, op, r) { Binop (op, l, r) }],
                   [s ("%"),  fun (l, op, r) { Binop (op, l, r) }]
                 }]},
        primary
      );

var stmt = memo $ eta syntax (
    kRead  x=inbr[s("("), lident, s(")")] { Read (x) }
  | kWrite x=inbr[s("("), exp, s(")")]    { Write (x) }
  | kSkip                                 { Skip }
  | x=lident s[":="] e=exp                { Assn (x, e) }
  | fst=stmt s[";"] snd=stmt end          { Seq (fst, snd) }
);

-- Public top-level parser
public parse = stmt;
