-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun f(l, op, r) {Binop(op, l, r)}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
                                 exp = memo $ expr({
                                  [Left, {[s("!!"), f]}],
                                  [Left, {[s("&&"), f]}],
                                  [Nona, {[s("=="), f], [s("!="), f], [s("<="), f], [s("<"), f], [s(">="), f], [s(">"), f]}],
                                  [Left, {[s("+"), f], [s("-"), f]}],
                                  [Left, {[s("*"), f], [s("/"), f], [s("%"), f]}]
                                 }, primary);

var stmt1 = memo $ eta syntax(
  kRead x=inbr[s("("), lident, s(")")] {Read(x)} |
  kWrite x=inbr[s("("), exp, s(")")] {Write(x)} |
  kSkip {Skip} |
  x=lident s[":="] y=exp {Assn(x, y)}
),

stmt = memo $ eta syntax(
  stmt1 | s1=stmt1 s[";"] s2=stmt {Seq(s1, s2)}
);

-- Public top-level parser
public parse = stmt;
