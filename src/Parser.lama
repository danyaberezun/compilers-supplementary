-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

fun wrapValue (v, loc) {
  fun (atr) {
    case atr of
      Val -> v
    | Weak -> v
    | Void -> Ignore (v)
    | Ref -> error ("Expected reference, got a plain value " ++ string (v), loc)
    esac
  }
}

fun wrapVoid (v, loc) {
  fun (atr) {
    case atr of
      Void -> v
    | Weak -> Seq (v, Const (0))
    | Val -> error ("Expected Val, got Void", loc)
    | Ref -> error ("Expected Ref, got Void", loc)
    esac
  }
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- A helper function to be used with super-combinator "expr"
fun binop (op) {
  [
    syntax (pos -s[op]),
    fun (l, loc, r) {
      wrapValue (Binop (op, l (Val), r (Val)), loc)
    }
  ]
}

-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s(","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope (defs, expr) {
  fun expandVarDefs (defs, expr) {
    foldr (fun ([defs, expr], def) {     
             case def of
                [ident, None]         -> [ident : defs, expr]
             |  [ident, Some (value)] -> [ident : defs, Seq (Ignore (Set (ident, value)), expr)]
             esac
           },
           [{}, expr],
           defs)
  }

  fun expandValDefs (defs, expr) {
    foldr (fun ([defs, expr], [ident, value]) {     
             [ident : defs, Seq (Ignore (Set (ident, value)), expr)]
           },
           [{}, expr],
           defs)
  }

  case 
    foldr (fun ([defs, expr], def) {
             case def of
               f@Fun (_, _, _) -> [f : defs, expr]
             | Val (ds) ->
                 case expandValDefs (ds, expr) of
                   [ds, expr] -> [Val (ds) : defs, expr]
                 esac
             | Var (ds) ->             
                 case expandVarDefs (ds, expr) of
                   [ds, expr] -> [Var (ds) : defs, expr]
                 esac
             esac
           },
           [{}, expr],
           defs) of
    [defs, expr] -> Scope (defs, expr)
  esac  
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope (expr, exprConstructor) {
  case expr of
    Scope (defs, sexpr) -> Scope (defs, exprConstructor (sexpr))
  | _                   -> exprConstructor (expr)
  esac
}
 
fun makeIf (cases, finalE) {
  fun (atr) {
    case cases of
      {} -> finalE (atr)
    | [cond, branch] : otherCases ->
      If (cond (Val), branch (atr), makeIf (otherCases, finalE) (atr))
    esac
  }
}

var primary = memo $ eta syntax (
  -- array constant
  loc=pos
  x=inbr[
    s ("["),
    list0 (syntax (e=exp { e (Val) })),
    s ("]")
  ] {
    wrapValue (Array (x), loc)
  }

| -- string constant
  loc=pos x=strlit {
    wrapValue (String (x), loc)
  }

| -- character literal
  loc=pos x=chrlit {
    wrapValue (Const (x), loc)
  } 

| -- decimal constant
  loc=pos x=decimal {
    wrapValue (Const (stringInt (x)), loc)
  }

| -- an identifier or a function call
  loc=pos
  x=lident
  args=inbr[s ("("), list0(syntax(e=exp {e (Val)})), s (")")]? {
    case args of
      None -> -- variable reference
        fun (atr) {
          case atr of
            Ref  -> Ref (x)
          | Void -> Ignore (Var (x))
          | _    -> Var (x)
          esac
        }
    | Some (args) -> -- function call
        wrapValue (Call (x, args), loc)
    esac
  } 

  -- S-expression
| loc=pos
  x=uident
  args=inbr[s ("("), list0 (syntax(e=exp { e (Val) })), s (")")]? {
    var argList = case args of
      None -> {}
    | Some (args) -> args
    esac;
    wrapValue (Sexp (x, argList), loc)
  }

| -- skip
  loc=pos -kSkip {
    wrapVoid (Skip, loc)
  }

| -- surrounded with brackets
  inbr[s ("("), scopeExpr, s (")")]

| -- if
  -kIf condE=exp
    -kThen thenE=scopeExpr
    elifBlocks=$(eta syntax (-kElif exp -kThen scopeExpr))*
    elseLoc=pos
    elseBlock=$(eta syntax (-kElse scopeExpr))?
  -kFi {
    var finalE = case elseBlock of
      Some (exp) -> exp
    | None -> wrapVoid (Skip, elseLoc)
    esac;
    makeIf ([condE, thenE] : elifBlocks, finalE)
  }

| -- while
  loc=pos -kWhile condE=exp kDo bodyE=scopeExpr -kOd {
    wrapVoid (While (condE (Val), bodyE (Void)), loc)
  }

| -- do-while
  loc=pos -kDo bodyE=scopeExpr -kWhile condE=exp kOd {
    var node = case bodyE (Void) of
      Scope (defs, bodyE) ->
        Scope (defs, DoWhile (bodyE, condE (Val)))
    | bodyE ->
        DoWhile (bodyE, condE (Val))
    esac;
    wrapVoid (node, loc)
  }

| -- for
  loc=pos -kFor initE=scopeExpr s[","] condE=exp s[","] stepE=exp -kDo
  bodyE=scopeExpr
  -kOd {
    var loop = While (
      condE (Val),
      Seq (
        bodyE (Void),
        stepE (Void)
      )
    );
    var withInit = case initE (Void) of
      Scope (initDefs, initBody) ->
        Scope (initDefs, Seq (initBody, loop))
    | initE -> Seq (initE, loop)
    esac;
    wrapVoid (withInit, loc)
  }
);

var basic = memo $ eta (
  expr (
    {
      [Right, {
          [
            s (":="),
            fun (l, loc, r) {
              wrapValue (Assn (l (Ref), r (Val)), loc)
            }
          ]
        }
      ],
      [Left, map (binop, {"!!"})],
      [Left, map (binop, {"&&"})],
      [Nona, map (binop, {"==", "!=", "<", ">", "<=", ">="})],
      [Left, map (binop, {"+", "-"})],
      [Left, map (binop, {"*", "/", "%"})]
   },
   postfix
 )
);

var postfix = memo $ eta syntax (
  loc=pos 
  e=primary
  ps=(i=inbr[s("["), exp, s("]")] { Index (i (Val)) })* {
    fun (a) {
      foldl (
        fun (e, p) {
          case p of 
            Index (i) -> fun (a) {
              case a of
                Ref -> ElemRef (e (Val), i)
              | _ -> 
                var vl = Elem (e (Val), i);
                case a of
                  Void -> Ignore (vl)
                | _ -> vl
                esac
              esac
            }
          esac
        },
        e,
        ps
      ) (a)
    }
  }
);

var scopeExpr  = memo $ eta syntax (ds=definition* e=exp? {fun (a) {fun (e) {
                                    case ds of
                                      {} -> e
                                    | _  -> expandScope (ds, e) 
                                    esac
                                  } (case e of 
                                       Some (e) -> e (a)
                                     | _        -> Skip
                                     esac)
                                  }}),
definition = memo $ eta syntax (kVar ds=list[syntax (lident (s["="] e=basic {e (Val)})?)] s[";"] {Var (ds)} |
  kVal ds=list[syntax (lident (s["="] e=basic {e (Val)}))]  s[";"] {Val (ds)} |
  kFun name=lident
       args=inbr[s("("), list0 (lident), s(")")]
       body=inbr[s("{"), scopeExpr, s("}")] {
       Fun (name, args, body (Weak))
  }
 ),                                    
exp        = memo $ eta syntax (basic | s1=basic s[";"] s2=exp {fun (a) {Seq (s1 (Void), s2 (a))}});

-- Public top-level parser
public parse = syntax (s=scopeExpr {s (Void)});