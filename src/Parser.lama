-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      binop = fun (l, op, r) { Binop (op, l, r) },
      exp = memo $ expr ({
        [Left, {
	  [s("^"), binop]
	}],
        [Left, {
	  [s("!!"), binop]
	}],
        [Left, {
	  [s("&&"), binop]
	}],
        [Nona, {
	  [s("<"), binop],
	  [s("<="), binop],
	  [s("=="), binop],
	  [s("!="), binop],
	  [s(">="), binop],
	  [s(">"), binop]
	}],
        [Left, {
	  [s("+"), binop],
	  [s("-"), binop]
	}],
        [Left, {
	  [s("*"), binop],
	  [s("/"), binop],
	  [s("%"), binop]
	}]
      }, primary);

var stmt = memo $ eta syntax (v=lident s[":="] e=exp { Assn (v, e) }            |
			      kSkip { Skip }                                    |
			      kRead v=inbr[s("("), lident, s(")")] { Read (v) } |
			      kWrite e=inbr[s("("), exp, s(")")] { Write (e) }  |
			      s=if_stmt { s } | s=while_stmt { s }),
   if_stmt = memo $ eta syntax (kIf e=exp kThen s1=stmt_seq s2=if_else { If (e, s1, s2) }),
   if_else = memo $ eta syntax (kFi { Skip } |
                                kElse s=stmt_seq kFi { s } |
                                kElif e=exp kThen s1=stmt_seq s2=if_else { If (e, s1, s2) }),
   while_stmt = memo $ eta syntax (kWhile e=exp kDo s=stmt_seq kOd { While (e, s) } |
                                   kDo s=stmt_seq kWhile e=exp kOd { DoWhile (s, e) } |
				   kFor init=stmt_seq s[","] e=exp s[","] each=stmt_seq kDo s=stmt_seq kOd { Seq (init, While (e, Seq (s, each)))}),
   stmt_seq = memo $ eta syntax (f=stmt s[";"] r=stmt_seq { Seq (f, r) } |
                                 s=stmt { s });
   

-- Public top-level parser
public parse = stmt_seq;
