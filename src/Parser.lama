-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp0, s(")")]),
    exp0 = memo $ eta syntax (x=exp1 {x} |
                              l=exp0 s["!!"] r=exp1 {Binop("!!", l, r)}),
    exp1 = memo $ eta syntax (x=exp2 {x} |
                              l=exp1 s["&&"] r=exp2 {Binop("&&", l, r)}),
    exp2 = memo $ eta syntax (x=exp3 {x} |
                              l=exp2 b=eq_priority_binops r=exp3 {Binop(b, l, r)}),
    exp3 = memo $ eta syntax (x=exp4 {x} |
                              l=exp3 b=add_priority_binops r=exp4 {Binop(b, l, r)}),
    exp4 = memo $ eta syntax (x=primary {x} |
                              l=exp4 b=mul_priority_binops r=primary {Binop(b, l, r)}),
    mul_priority_binops = memo $ eta syntax( b=(s["*"] | s["%"] | s["/"]) {b} ),
    add_priority_binops = memo $ eta syntax( b=(s["-"] | s["+"]) {b} ),
    eq_priority_binops = memo $ eta syntax( b=(s["<"] | s[">"] | s["<="] | s[">="] | s["=="] | s["!="]) {b} );

var stmts = memo $ eta syntax (
      statement=stmt {statement} |
      l=stmt s[";"] r=stmts {Seq (l, r)}
    ),

    stmt = memo $ eta syntax (
      vn=lident s[":="] exp=exp0 {Assn (vn, exp)} |
      kRead s["("] l=lident s[")"] {Read (l)} |
      kWrite s["("] exp=exp0 s[")"] {Write (exp)} |
      kSkip {Skip}
    );

-- Public top-level parser
public parse = stmts;
             
