-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]
);

var addExp = memo $ eta syntax (
  unary = mulExp {unary} |
  l = addExp op = (s["+"] {"+"} | 
                   s["-"] {"-"}) 
  r = mulExp {Binop(op, l, r)}
);

var mulExp = memo $ eta syntax (
  primaryExp = primary {primaryExp} |
  l = mulExp op = (s["*"] {"*"} | 
                   s["/"] {"/"} | 
                   s["%"] {"%"}) 
  r = primary {Binop(op, l, r)}
);

var cmpExp = memo $ eta syntax (
  cmp = addExp {cmp} |
  l = cmpExp op = (s["=="] {"=="} | 
                   s["!="] {"!="} |
                   s[">"]  {">"}  | 
                   s["<"]  {"<"}  |
                   s[">="] {">="} | 
                   s["<="] {"<="}) 
  r = addExp {Binop(op, l, r)}
);

var andClause = memo $ eta syntax (
  cmp = cmpExp {cmp} |
  l = andClause s["&&"] r = cmpExp {Binop("&&", l, r)}
);

var exp = memo $ eta syntax (
  and = andClause {and} |
  l = exp s["!!"] r = andClause {Binop("!!", l, r)}
);

var pStmt = memo $ eta syntax (
  kSkip                                   {Skip} |
  varName  = lident s[":="] value = exp   {Assn (varName, value)} |
  kRead x  = inbr[s("("), lident, s(")")] {Read (x)} |
  kWrite e = inbr[s("("), exp, s(")")]    {Write (e)}
);

var stmt = memo $ eta syntax (
  pStmt | 
  stmt1 = pStmt s[";"] stmt2 = stmt {Seq (stmt1, stmt2)}
);

-- Public top-level parser
public parse = stmt;
             
