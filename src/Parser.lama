-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]
);

var addExp = memo $ eta syntax (
   unary = mulExp {unary} |
   l = addExp op = (s["+"] {"+"} | 
                    s["-"] {"-"}) 
   r = mulExp {Binop(op, l, r)}
);
 
 var mulExp = memo $ eta syntax (
   primaryExp = primary {primaryExp} |
   l = mulExp op = (s["*"] {"*"} | 
                    s["/"] {"/"} | 
                    s["%"] {"%"}) 
   r = primary {Binop(op, l, r)}
 );
 
 var cmpExp = memo $ eta syntax (
   cmp = addExp {cmp} |
   l = cmpExp op = (s["=="] {"=="} | 
                    s["!="] {"!="} |
                    s[">"]  {">"}  | 
                    s["<"]  {"<"}  |
                    s[">="] {">="} | 
                    s["<="] {"<="}) 
   r = addExp {Binop(op, l, r)}
 );
 
 var andClause = memo $ eta syntax (
   cmp = cmpExp {cmp} |
   l = andClause s["&&"] r = cmpExp {Binop("&&", l, r)}
 );
 
 var exp = memo $ eta syntax (
   and = andClause {and} |
   l = exp s["!!"] r = andClause {Binop("!!", l, r)}
 );
  
var postIf = memo $ eta syntax (
  kFi {Skip} |
  kElse s = stmt kFi {s} |
  kElif e = exp kThen s = stmt p = postIf {If (e, s, p)}
);

var pStmt = memo $ eta syntax (
  kSkip                                   {Skip} |
  varName  = lident s[":="] value = exp   {Assn (varName, value)} |
  kRead x  = inbr[s("("), lident, s(")")] {Read (x)} |
  kWrite e = inbr[s("("), exp, s(")")]    {Write (e)} |
  kIf e = exp kThen s1 = stmt s2 = postIf {If (e, s1, s2)} | 
  kWhile e = exp kDo s = stmt kOd      {While (e, s)} |
  kDo s = stmt kWhile e = exp kOd      {DoWhile (s, e)} |
  kFor s1 = stmt s[","] e = exp s[","] s2 = stmt kDo s3 = stmt kOd {Seq (s1, While (e, Seq (s3, s2)))}
);

var stmt = memo $ eta syntax (
  pStmt | 
  stmt1 = pStmt s[";"] stmt2 = stmt {Seq (stmt1, stmt2)}
);

-- Public top-level parser
public parse = stmt;
