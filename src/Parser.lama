-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta syntax (x=expNo5 {x} |
                               l=exp s["!!"] r=expNo5 {Binop("!!", l, r)}),
      expNo5 = memo $ eta syntax (x=expNo4 {x} |
                                  l=expNo5 s["&&"] r=expNo4 {Binop("&&", l, r)}),
      expNo4 = memo $ eta syntax (x=expNo3 {x} |
                                  l=expNo4 b=binop3 r=expNo3 {Binop(b, l, r)}),
      expNo3 = memo $ eta syntax (x=expNo2 {x} |
                                  l=expNo3 b=binop2 r=expNo2 {Binop(b, l, r)}),
      expNo2 = memo $ eta syntax (x=primary {x} |
                                  l=expNo2 b=binop1 r=primary {Binop(b, l, r)}),
      binop1 = memo $ eta syntax(
        b=(s["*"] | s["/"] | s["%"]) {b}
      ),
      binop2 = memo $ eta syntax(
        b=(s["+"] | s["-"]) {b}
      ),
      binop3 = memo $ eta syntax(
        b=(s["=="] | s["!="] | s[">"] | s["<"] | s[">="] | s["<="]) {b}
      );

var stmt = memo $ eta syntax (
  st=singleStmt {st} |
  l=singleStmt s[";"] r=stmt {Seq (l, r)}
),

singleStmt = memo $ eta syntax (
  x=kSkip {Skip} |
  r=kRead s["("] l=lident s[")"] {Read (l)} |
  w=kWrite s["("] e=exp s[")"] {Write (e)} |
  v=lident s[":="] e=exp {Assn (v, e)} | 
  x1=kIf e=exp x2=kThen s1=stmt n=endIf {If (e, s1, n)} | 
  x1=kWhile e=exp x2=kDo s=stmt x3=kOd {While (e, s)} |
  x1=kDo s=stmt x2=kWhile e=exp x3=kOd {DoWhile (s, e)} | 
  x1=kFor init=stmt s[","] cond=exp s[","] inc=stmt x2=kDo body=stmt x3=kOd {Seq(init, While(cond, Seq(body, inc)))}
),

endIf = memo $ eta syntax (
  x1=kElse s=stmt x2=kFi {s} |
  x1=kElif e=exp x2=kThen s=stmt n=endIf {If (e, s, n)} |
  x=kFi {Skip}
)
;
   

-- Public top-level parser
public parse = stmt;
