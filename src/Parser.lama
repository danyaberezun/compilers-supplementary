-- Parser 

import Matcher;
import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopS (opRe) {
  s (createRegexp (opRe, "binop<" ++ opRe ++ ">"))
}

var opOr  = binopS ("!!");
var opAnd = binopS ("&&");
var opCmp = binopS ("(<=?|>=?|==|!=)");
var opAdd = binopS ("(+|-)");
var opMd  = binopS ("(\*|\/|%)");

var lb = s ("(");
var rb = s (")");

-- Primary expression
var primary = memo $ eta syntax ( x=decimal {Const (stringInt (x))}
                                | x=lident  {Var (x)}
                                | inbr[s("("), exp, s(")")] ),
      exp = memo $ eta syntax ( primary
                              | l=exp op=opOr  r=exp {Binop (op, l, r)}
                              | l=exp op=opAnd r=exp {Binop (op, l, r)}
                              | l=exp op=opCmp r=exp {Binop (op, l, r)}
                              | l=exp op=opAdd r=exp {Binop (op, l, r)}
                              | l=exp op=opMd  r=exp {Binop (op, l, r)} );

var stmt = memo $ eta syntax ( x=lident s[":="] e=exp {Assn (x, e)}
                             | s=stmt s[";"] t=stmt   {Seq (s, t)}
                             | kSkip                  {Skip}
                             | kRead  lb x=lident rb  {Read (x)}
                             | kWrite lb x=lident rb  {Write (x)} );
   

-- Public top-level parser
public parse = stmt;
