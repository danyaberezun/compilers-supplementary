-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), pOr, s(")")]),

    pAdd = memo $ eta syntax (e=pMul {e} | 
                              l=pAdd operator=(s["+"] {"+"} | s["-"] {"-"})
                              r=pMul {Binop(operator, l, r)}),

    pMul = memo $ eta syntax (e=primary {e} |
                              l=pMul operator=(s["*"] {"*"} | s["/"] {"/"} | s["%"] {"%"})
                              r=primary {Binop(operator, l, r)}),

    pAnd = memo $ eta syntax (e=pCmp {e} |
                              l=pAnd s["&&"] 
                              r=pCmp {Binop("&&", l, r)}),

    pOr = memo $ eta syntax (e=pAnd {e} |
                             l=pOr s["!!"] 
                             r=pAnd {Binop("!!", l, r)}),

    pCmp = memo $ eta syntax (e=pAdd {e} |
                              l=pCmp operator=(s[">"] {">"} | s["<"] {"<"} | s[">="] {">="} | s["<="] {"<="} | s["=="] {"=="} | s["!="] {"!="})
                              r=pAdd {Binop(operator, l, r)}),

    stmt = memo $ eta syntax (x=lident s[":="] e=pOr {Assn (x, e)} |
                              kSkip {Skip} |
                              kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
                              kWrite e=inbr[s("("), pOr, s(")")] {Write (e)}),

    code = memo $ eta syntax (stmt | s1=stmt s[";"] s2=code {Seq (s1, s2)});

-- Public top-level parser
public parse = code;
             
