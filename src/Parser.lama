-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    binop = fun(l, op, r) { Binop(op, l, r) },
    exp = memo $ expr({
        [Left, {[s("!!"), binop]}],
        [Left, {[s("&&"), binop]}],
        [Nona, {
            [s("=="), binop], [s("!="), binop],
            [s("<="), binop], [s(">="), binop],
            [s("<"), binop], [s(">"), binop]
        }],
        [Left, {[s("+"), binop], [s("-"), binop]}],
        [Left, {[s("*"), binop], [s("/"), binop], [s("%"), binop]}]
    }, primary);

var stmt = memo $ list0By(eta syntax (
        kSkip { Skip } |
        kRead v=inbr[s("("), lident, s(")")] { Read(v) } |
        kWrite x=inbr[s("("), exp, s(")")] { Write(x) } |
        kIf x=exp kThen s=stmt cont=ifCont { If(x, s, cont) } |
        kWhile x=exp kDo s=stmt kOd { While(x, s) } |
        kDo s=stmt kWhile x=exp kOd { DoWhile(s, x) } |
        kFor init=stmt s[","] cond=exp s[","] inc=stmt kDo body=stmt kOd 
            { Seq(init, While(cond, Seq(body, inc))) } |
        v=lident s[":="] x=exp { Assn(v, x) }
    ), s(";")) @ fun(a) {
        case a of
          {} -> Skip
        | first:rest -> foldl (fun(x, y) { Seq(x, y) }, first, rest)
        esac
    },
    ifCont = memo $ eta syntax (
        kElif x=exp kThen s=stmt cont=ifCont { If(x, s, cont) }
        | kElse s=stmt kFi { s }
        | kFi { Skip }
    );

-- Public top-level parser
public parse = stmt;
